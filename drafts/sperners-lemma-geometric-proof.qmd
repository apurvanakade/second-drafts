---
title: Sperner's Lemma - Geometric Proof
author: Apurva Nakade
date: 2025-05-22 10:23:17
categories: [triangles, coloring, questions, visualization, interactive, observablejs]
draft: true
---

**DRAFT DOCUMENT**

```{ojs}
import {slider} from "@jashkenas/inputs"
```

```{ojs}
viewof N = slider({
  min: 2, max: 10, step: 1, value: 2, width: 500, title: "Number of subdivisions"
})
```

```{ojs}
viewof t = slider({
  min: 0, max: 1, step: 0.01, value: 0, width: 500, title: "time"
})
```

```{ojs}
equilateralTriangleVertices = [
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2},
  {x: 0, y: 0},
]
```

```{ojs}
generateBarycentricCoords = N => {
  const coords = []
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      coords.push([i, j, N - i - j])
    }
  }
  return coords
}

barycentricCoords = generateBarycentricCoords(N)
```

```{ojs}
pickRandomColor = (...options) => options[Math.floor(Math.random() * options.length)]
```

```{ojs}
assignColor = (a, b, c) => {
  if (a === 0 && b === 0) return 'red'
  if (b === 0 && c === 0) return 'green'
  if (c === 0 && a === 0) return 'blue'

  if (a === 0) return pickRandomColor('red', 'blue')
  if (b === 0) return pickRandomColor('red', 'green')
  if (c === 0) return pickRandomColor('blue', 'green')

  return pickRandomColor('red', 'green', 'blue')
}
```

```{ojs}
buildColorMap = N => {
  const map = new Map()
  const baryCoords = generateBarycentricCoords(N)
  baryCoords.forEach(([a, b, c]) => {
    map.set(`${a},${b},${c}`, assignColor(a, b, c))
  })
  return map
}

colorMap = buildColorMap(N)
```

```{ojs}
// Sinusoidal easing function mapping [0,1] â†’ [0,1]
sinusoidalEase = t => (1 - Math.cos(Math.PI * t)) / 2;

smoothstepEase = t => (3 * t * t - 2 * t * t * t);

smootherstepEase = t => (6 * t**5 - 15 * t**4 + 10 * t**3);

// In your interpolatePoints method
interpolatePoints = (t, baryCoords, vertices, colorMap) => {
  const vertexMap = {
    red: vertices[2],
    green: vertices[0],
    blue: vertices[1],
  }
  const [A, B, C] = vertices

  const s = smootherstepEase(t);

  const morphedPoints = baryCoords.map(([a, b, c]) => {
    const sum = a + b + c;
    const x0 = (a * A.x + b * B.x + c * C.x) / sum;
    const y0 = (a * A.y + b * B.y + c * C.y) / sum;

    const color = colorMap.get(`${a},${b},${c}`);
    const vertex = vertexMap[color];

    return {
      x: (1 - s) * x0 + s * vertex.x,
      y: (1 - s) * y0 + s * vertex.y,
      color,
      barycentricTriple: [a, b, c]
    };
  });

  const morphedMap = new Map(morphedPoints.map(p => [
    p.barycentricTriple.join(','), p
  ]));

  return { morphedPoints, morphedMap };
}

morphedColoredPointsMap = interpolatePoints(t, barycentricCoords, equilateralTriangleVertices, colorMap)
```

```{ojs}
generateSubTriangles = (N, morphedMap) => {
  const triangles = []

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coords1 = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ]
      const vertex_colors1 = coords1.map(c => morphedMap.get(c.join(',')).color)
      triangles.push({ coordinates: coords1, vertex_colors: vertex_colors1 })
    }
  }

  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coords2 = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ]
      const vertex_colors2 = coords2.map(c => morphedMap.get(c.join(',')).color)
      triangles.push({ coordinates: coords2, vertex_colors: vertex_colors2 })
    }
  }

  return triangles
}
```

```{ojs}
subTriangles = generateSubTriangles(N, morphedColoredPointsMap.morphedMap)
```

```{ojs}
fillColorGroups = {
  const group1 = new Set(['RGB', 'GBR', 'BRG'])
  const group2 = new Set(['RBG', 'BGR', 'GRB'])
  return { group1, group2 }
}
```

```{ojs}
getFillColorRGB = vertexColors => {
  const map = { red: 'R', green: 'G', blue: 'B' }
  const orientation = vertexColors.map(c => map[c.toLowerCase()] || '').join('').toUpperCase()

  if (fillColorGroups.group1.has(orientation)) return 'rgba(255, 145, 0, 0.25)'
  if (fillColorGroups.group2.has(orientation)) return 'rgba(0, 128, 128, 0.25)'
  return 'none'
}
```

```{ojs}
createFeature = (triangle, morphedMap) => {
  const coords = triangle.coordinates.map(c => {
    const p = morphedMap.get(c.join(',')) || { x: 0, y: 0 }
    return { x: p.x, y: p.y }
  })

  return {
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: [[
        [coords[0].x, coords[0].y],
        [coords[1].x, coords[1].y],
        [coords[2].x, coords[2].y],
        [coords[0].x, coords[0].y],
      ]],
    },
    properties: {
      fillColor: getFillColorRGB(triangle.vertex_colors),
      coords,
      vertexColors: triangle.vertex_colors,
    },
  }
}
```

```{ojs}
viewof plotRGB = Plot.plot({
  width: 800,
  height: 800,
  x: {label: "x", domain: [0, 1]},
  y: {label: "y", domain: [0, Math.sqrt(3) / 2]},
  marks: [
    Plot.line([...equilateralTriangleVertices, equilateralTriangleVertices[0]], {
      x: "x",
      y: "y",
      stroke: "black",
      strokeWidth: 1
    }),
    Plot.geo({
      type: "FeatureCollection",
      features: subTriangles.map(tri => createFeature(tri, morphedColoredPointsMap.morphedMap))
    }, {
      fill: d => d.properties.fillColor,
      stroke: "black",
      strokeWidth: 1
    }),
    Plot.dot(morphedColoredPointsMap.morphedPoints, {
      x: "x",
      y: "y",
      fill: d => d.color,
      r: 5 * (5 / N)
    })
  ]
})
```