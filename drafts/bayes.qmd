---
title: Bayes theorem
---

**DRAFT DOCUMENT**

```{ojs}
// Updated centralized configuration for colors
configColors = ({
  leftRegion: "red",    // Soft orange
  rightRegion: "black",
  outline: "black",          // Outline color
  positiveRegion: "yellow"
})
```

```{ojs}
width = 700;
height = 300;
initialPrevalence = 0.5; // Prevalence is now between 0 and 1
initialSensitivity = 0.8;
initialSpecificity = 0.9;
halfWidth = width / 2 - 5;  // Half width with a small gap
pointCount = 10000;         // Increased number of points
pointRadius = 2.5;         // Smaller point size
```

```{ojs}
// Generate the points once and store them
points = Array.from({ length: pointCount }, () => ({
  x: Math.random() * width,
  y: Math.random() * height
}));
```

```{ojs}
// Calculate positions of sensitivity and specificity lines
prevalenceLinePosition = prevalence * width; // Prevalence scaled to canvas width
sensitivityLinePosition = prevalenceLinePosition - prevalenceLinePosition * sensitivity;
specificityLinePosition = width - (width - prevalenceLinePosition) * specificity;

// Function for creating horizontal sliders
function createSlider(min, max, value, step, width, rtl = false) {
  const directionStyle = rtl ? "direction: rtl;" : "";
  return html`<input type="range" 
    min="${min}" max="${max}" step="${step}" value="${value}" 
    style="width:${width}px; ${directionStyle}">`;
}

// Horizontal sliders for prevalence, sensitivity, and specificity
viewof prevalence = createSlider(0, 1, initialPrevalence, 0.01, width); 
viewof sensitivity = createSlider(0, 1, initialSensitivity, 0.01, halfWidth, true);
viewof specificity = createSlider(0, 1, initialSpecificity, 0.01, halfWidth, true);
```

```{ojs}
// Function for rendering the canvas visualization
function drawCanvas() {
  const canvas = DOM.canvas(width, height);
  const context = canvas.getContext("2d");
  
  // Draw regions and lines
  const drawRect = (x, w, color) => {
    context.fillStyle = color;
    context.fillRect(x, 0, w, height);
  };
  
  // drawRect(0, sensitivityLinePosition, configColors.negativeRegion);
  // drawRect(specificityLinePosition, width - specificityLinePosition, configColors.negativeRegion);
  drawRect(sensitivityLinePosition, specificityLinePosition - sensitivityLinePosition, configColors.positiveRegion);
  
  context.strokeStyle = configColors.outline;
  context.lineWidth = 2;
  context.strokeRect(0, 0, width, height);
  
  const drawLine = (x, color, lineWidth = 2) => {
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo(x, 0);
    context.lineTo(x, height);
    context.stroke();
  };
  
  // Draw points
  for (const point of points) {
    context.fillStyle = point.x < prevalenceLinePosition ? configColors.leftRegion : configColors.rightRegion;
    context.beginPath();
    context.arc(point.x, point.y, pointRadius, 0, 2 * Math.PI);
    context.fill();
  }
  
  // drawLine(prevalenceLinePosition, configColors.prevalenceLine); // Use prevalenceLinePosition
  drawLine(sensitivityLinePosition, configColors.outline, 10);
  drawLine(specificityLinePosition, configColors.outline, 10);
  return canvas;
}

viewof canvas = drawCanvas();

// Simple table layout for sliders
html`
<table style="border-collapse: collapse; border: none; width: ${width}px; margin-top: 10px;">
  <tr>
    <td style="padding: 0; width: 50%;">${viewof sensitivity}</td>
    <td style="padding: 0; width: 50%;">${viewof specificity}</td>
  </tr>
</table>
`;
```