---
title: "Generating random points in a triangle"
author: Apurva Nakade
date: 2025-05-12 17:22:57
categories: [randomness, triangles, barycentric coordinates]
---

Randomness is a surprisingly hard thing to generate. Any program, by definition has predictable output. The best you can hope for is predictably generate points that look random (pseudo-random) and fool statistical tests. 

All random generation relies on two things:

1. a Pseudo-random number generator that outputs a single number that "looks random"
2. a mathematical function that converts uniform random variable(s) into random variables with other distributions. 

The mathematical game is to engineer Step 2. Step 1 is of great importance, but is usually delegated to computer scientists and engineers.

With that preamble, here's the question: **Generate points randomly inside a triangle.** I need this in order to play around with Sperner's lemma examples. 

The first step is to generate random points in the "standard triangle" with vertices $[0, 0], [1, 0], [0, 1]$. A very simple trick for this is to generate points in the unit square and "reflect the points" across the midpoint of the hypotenuse, $[0.5, 0.5]$.

```{python}
import numpy as np

N = 500

# generate N random vectors in 2D
square_points = np.random.rand(N, 2)

# Plot 1. the unit square, 2. the triangle, 3. the random points
import matplotlib.pyplot as plt


# Separate points into red (inside the triangle) and blue (reflected)
red_points = square_points[square_points.sum(axis=1) <= 1]
blue_points = 1 - square_points[square_points.sum(axis=1) > 1]


plt.figure(figsize=(8, 8))
plt.plot([0, 1, 0, 0], [0, 0, 1, 0], 'k-')
plt.plot([0, 1], [0, 0], 'k--')
plt.plot([0, 0], [0, 1], 'k--')

# scatter the red points
plt.scatter(red_points[:, 0], red_points[:, 1], color='red')

# scatter the blue points
plt.scatter(blue_points[:, 0], blue_points[:, 1], color='blue', label='Reflected points')

# add a legend
plt.legend()
# add a title
plt.title('Random Points in a Triangle')

plt.show()
```

Next we use the [barycentric transformation](9998%20barycentric%20coordinates.qmd) to transform the standard triangle into the desired triangle, in this case, the equilateral triangle with vertices $[0, 0], [1, 0], [0.5, \sqrt{3}/2]$.

```{python}

vertices = np.array([[0, 0], [1, 0], [0.5, np.sqrt(3)/2]])

# plot the triangle
plt.figure(figsize=(8, 8))
plt.plot([vertices[0][0], vertices[1][0], vertices[2][0], vertices[0][0]],
     [vertices[0][1], vertices[1][1], vertices[2][1], vertices[0][1]], 'k-')

# use red_points as barycentric coordinates
for point in red_points:
    # barycentric coordinates
    barycentric_coords = np.array([1 - point[0] - point[1], point[0], point[1]])
    # transform the point
    transformed_point = np.dot(barycentric_coords, vertices)
    plt.scatter(transformed_point[0], transformed_point[1], color='red')


# use blue_points as barycentric coordinates
for point in blue_points:
    # barycentric coordinates
    barycentric_coords = np.array([1 - point[0] - point[1], point[0], point[1]])
    # transform the point
    transformed_point = np.dot(barycentric_coords, vertices)
    plt.scatter(transformed_point[0], transformed_point[1], color='blue')

# add a title
plt.title('Transformed Random Points in a Triangle')
plt.show()
```
