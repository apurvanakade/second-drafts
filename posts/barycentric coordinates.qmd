---
title: "Barycentric Coordinates"
date: 2025-05-11 02:55:36
format:
  html:
    code-fold: true
    code-summary: "Show the code"
author: Apurva Nakade
categories: [affine geometry, observablejs, triangles, interactive, visualization]
---

```{ojs}
import { Triangle, DraggableTriangle, Canvas } from "../scripts/triangle.js";

```

```{ojs}
// === Observable viewof canvas ===
viewof canvas = {
  const width = 800, height = 400;
  const scale = 200, offset = [50, 250];
  const canvasInstance = new Canvas(width, height, scale, offset);
  const canvas = canvasInstance.getCanvas();
  const ctx = canvasInstance.getContext();

  const A = [0, 0], B = [1, 0], C = [0, 1];
  let A2 = [1.5, 0], B2 = [3, 0], C2 = [2, 1];

  let target = { i: 0.3, j: 0.3 };
  let current = { i: 0.3, j: 0.3 };
  let draggingVertex = null;

  function draw() {
    ctx.clearRect(0, 0, width, height);

    const blackTri = canvasInstance.newTriangle(A, B, C);
    blackTri.drawGrid();
    blackTri.draw({ fillStyle: "rgba(0,0,0,0.2)", strokeStyle: "black" });

    const redTri = canvasInstance.newTriangle(A2, B2, C2);
    redTri.drawGrid();
    redTri.draw({ strokeStyle: "red", vertexColor: "red" });

    const k = 1 - current.i - current.j;
    const [x, y] = blackTri.barycentricToCartesian(current.i, current.j);
    canvasInstance.drawPoint([x, y], "blue");

    const [gx, gy] = redTri.barycentricToCartesian(current.i, current.j);
    canvasInstance.drawPoint([gx, gy], "green");

    ctx.fillStyle = "black";
    ctx.font = "14px sans-serif";
    ctx.fillText(`i = ${current.i.toFixed(2)}, j = ${current.j.toFixed(2)}, k = ${k.toFixed(2)}`, 75, height - 100);
    ctx.fillText(`x = ${gx.toFixed(2)}, y = ${gy.toFixed(2)}`, 420, height - 100);
  }

  function animate() {
    const alpha = 0.2;
    current.i += alpha * (target.i - current.i);
    current.j += alpha * (target.j - current.j);
    draw();
    requestAnimationFrame(animate);
  }

  function handleMouse(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const [x, y] = canvasInstance.fromCanvas([mx, my]);
    const blackTri = canvasInstance.newTriangle(A, B, C);
    const [bi, bj] = blackTri.cartesianToBarycentric(x, y);
    const snapTol = 0.05;
    const vertices = [[1, 0], [0, 1], [0, 0]];
    const dists = vertices.map(([vi, vj]) => Math.hypot(bi - vi, bj - vj));
    const minDist = Math.min(...dists);
    if (minDist < snapTol) {
      [target.i, target.j] = vertices[dists.indexOf(minDist)];
    } else if (bi >= 0 && bj >= 0 && bi + bj <= 1) {
      target.i = bi;
      target.j = bj;
    }
  }

  function handleDrag(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (draggingVertex !== null) {
      if (draggingVertex === 0) A2 = canvasInstance.fromCanvas([mx, my]);
      else if (draggingVertex === 1) B2 = canvasInstance.fromCanvas([mx, my]);
      else if (draggingVertex === 2) C2 = canvasInstance.fromCanvas([mx, my]);
      draw();
    } else {
      handleMouse(e);
    }
  }

  canvas.addEventListener("mousedown", e => {
    const mx = e.clientX - canvas.getBoundingClientRect().left;
    const my = e.clientY - canvas.getBoundingClientRect().top;
    draggingVertex = null;
    [A2, B2, C2].forEach(([x, y], idx) => {
      const [cx, cy] = canvasInstance.toCanvas([x, y]);
      if (Math.hypot(mx - cx, my - cy) < 10) draggingVertex = idx;
    });

    handleDrag(e);
    const move = e => handleDrag(e);
    const up = () => {
      draggingVertex = null;
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", up);
    };
    window.addEventListener("mousemove", move);
    window.addEventListener("mouseup", up);
  });

  requestAnimationFrame(animate);
  return canvas;
}
```
**Barycentric coordinates** are a coordinate system for describing points within a triangle.  

For a triangle with vertices $A$, $B$, and $C$, any point $P$ inside the triangle can be expressed as a weighted sum of the vertices:
$$
P = iA + jB + kC
$$
where $i$, $j$, and $k$ are the barycentric coordinates, satisfying $i + j + k = 1$ and $i, j, k \geq 0$. The barycentric coordinates can be interpreted as the relative areas of the sub-triangles formed with the point $P$ and the vertices of the triangle.

There are many ways of seeing why this is true. Here's one visual interpretation: First consider the triangle with vertices $(0, 0)$, $(1, 0)$, and $(0, 1)$. A point $(x, y)$ is inside this triangle exactly when:
$$
0 \le x, \quad 0 \le y, \quad \text{and} \quad x + y \le 1
$$
In this case, we can write the point $(x, y)$ as:
$$
\begin{bmatrix} x \\ y \end{bmatrix}
= 
(1 - x - y) \begin{bmatrix} 0 \\ 0 \end{bmatrix} + 
x \begin{bmatrix} 1 \\ 0 \end{bmatrix} +
y \begin{bmatrix} 0 \\ 1 \end{bmatrix}
$$
So the barycentric coordinates of $(x, y)$ are $(1 - x - y, x, y)$, all of which are non-negative and sum to 1. Now all you need to do is map $(0, 0)$, $(1, 0)$, and $(0, 1)$ to the vertices of the triangle $A$, $B$, and $C$, respectively, via an affine transformation. The barycentric coordinates of a point $P$ inside the triangle with vertices $A$, $B$, and $C$ are given by the same formula as above, with the standard triangle's vertices replaced by $A$, $B$, and $C$.

You can see this in the app above: move the blue point around the triangle and watch how the barycentric coordinates change. You can also move the vertices of the red triangle and observe how the coordinates adapt.

---

This post was an excuse for me to learn how to use ObservableJS. I was initially planning on using Python and Plotly, but Plotly is absurdly immature in terms of interactivity. Most of the code is generated by ChatGPT. I merely edited it to fit my needs. 


<!-- 
TODO: Export javascript classes to separate files.
TODO: Write a little about the javascript implementation.
TODO: Instead of A, B, C use an array of vertices in the triangle class.
TODO: Extend triangle class to a draggable triangle class.
 -->