---
title: "Barycentric Coordinates Interaction"
output: html_document
---

```{ojs}
import {html, style} from "@observablehq/stdlib";

// Create the interactive canvas
viewof point = {
  const width = 600, height = 400;
  const margin = 20;
  
  // Set up the canvas
  const canvas = html`<canvas width="${width}" height="${height}"></canvas>`;
  const ctx = canvas.getContext("2d");

  // Triangle vertices for the equilateral triangle
  const A = [0, 0];
  const B = [0.5, Math.sqrt(3) / 2];
  const C = [1, 0];

  // Define the region x + y <= 1 in the first quadrant (input triangle)
  function drawRegion() {
    ctx.clearRect(0, 0, width, height);

    // Draw the original triangle with coordinates (0, 0), (1, 0), (0, 1)
    ctx.beginPath();
    ctx.moveTo(margin, height - margin); // (0, 0)
    ctx.lineTo(width / 2 - margin, height - margin); // (1, 0)
    ctx.lineTo(margin, height / 2 + margin); // (0, 1)
    ctx.closePath();
    ctx.fillStyle = "lightgray";
    ctx.fill();

    // Draw the vertices of the original triangle
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(margin, height - margin, 5, 0, Math.PI * 2); // (0, 0)
    ctx.fill();
    ctx.beginPath();
    ctx.arc(width / 2 - margin, height - margin, 5, 0, Math.PI * 2); // (1, 0)
    ctx.fill();
    ctx.beginPath();
    ctx.arc(margin, height / 2 + margin, 5, 0, Math.PI * 2); // (0, 1)
    ctx.fill();
    
    // Draw the equilateral triangle (side by side)
    const equilateralVertices = [
      {x: width / 2 + 200, y: margin + 100},
      {x: width / 2 + 100, y: margin + 250},
      {x: width / 2 + 300, y: margin + 250}
    ];
    
    ctx.beginPath();
    ctx.moveTo(equilateralVertices[0].x, equilateralVertices[0].y);
    equilateralVertices.forEach(v => ctx.lineTo(v.x, v.y));
    ctx.closePath();
    ctx.strokeStyle = "blue";
    ctx.stroke();
    
    // Draw the vertices of the equilateral triangle
    ctx.fillStyle = "blue";
    equilateralVertices.forEach(v => {
      ctx.beginPath();
      ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Handle the dragging of the black point
  let dragPoint = {x: 0.5, y: 0.5}; // Initial point inside the triangle
  let isDragging = false;

  // Function to constrain the point to the region x + y <= 1 (the input triangle)
  function constrainToTriangle(x, y) {
    // Ensure that the point stays inside the triangle
    if (x + y > 1) {
      return {x: 1 - y, y: 1 - x}; // Reflect the point to keep it inside
    }
    return {x, y};
  }

  canvas.addEventListener("mousedown", (e) => {
    const {offsetX, offsetY} = e;
    const x = (offsetX - margin) / (width - 2 * margin);
    const y = (height - offsetY - margin) / (height - 2 * margin);
    
    if (x + y <= 1) { // Inside the region
      isDragging = true;
      dragPoint = {x, y};
      draw();  // Redraw the canvas with the black dot
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (isDragging) {
      const {offsetX, offsetY} = e;
      let x = (offsetX - margin) / (width - 2 * margin);
      let y = (height - offsetY - margin) / (height - 2 * margin);
      
      const constrainedPoint = constrainToTriangle(x, y);
      dragPoint = constrainedPoint;
      draw();
    }
  });

  canvas.addEventListener("mouseup", () => {
    isDragging = false;
  });

  // Barycentric to Cartesian conversion function for equilateral triangle
  function barycentricToCartesian(i, j) {
    const k = 1 - i - j;
    return [
      i * A[0] + j * B[0] + k * C[0],
      i * A[1] + j * B[1] + k * C[1]
    ];
  }

  // Draw the red point based on barycentric coordinates
  function draw() {
    drawRegion();
    
    // Black dot (where clicked)
    const blackX = dragPoint.x * (width - 2 * margin) + margin;
    const blackY = (1 - dragPoint.y) * (height - 2 * margin) + margin;
    
    ctx.beginPath();
    ctx.arc(blackX, height - blackY, 5, 0, Math.PI * 2);
    ctx.fillStyle = "black";
    ctx.fill();

    // Red dot (based on barycentric coordinates)
    const baryX = dragPoint.x;
    const baryY = dragPoint.y;

    const [redX, redY] = barycentricToCartesian(baryX, baryY);

    // Scale and shift the red point to match the equilateral triangle's canvas position
    const equilateralShiftX = width / 2 + 200;
    const equilateralShiftY = margin + 100;

    const redCartesianX = redX * 300 + equilateralShiftX;
    const redCartesianY = redY * 300 + equilateralShiftY;

    ctx.beginPath();
    ctx.arc(redCartesianX, redCartesianY, 5, 0, Math.PI * 2);
    ctx.fillStyle = "red";
    ctx.fill();
  }

  draw();
  return canvas;
}
```