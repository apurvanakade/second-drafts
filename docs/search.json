[
  {
    "objectID": "posts/begin-again.html",
    "href": "posts/begin-again.html",
    "title": "Begin Again",
    "section": "",
    "text": "I opened this page with a clear idea of what I wanted to write. I’ve now spent the last half hour updating quarto, setting up a new git repository, fixing a git merge issue, figuring out how to render drafts… this was a mistake. When I have something to write, I need to get the words out as soon as possible without worrying about their final destination.\n\nOne of the protagonist in 1Q84, Tengo, is a writer. He teaches math at cram schools to make a living but his real passion is writing. At some point in his life he has to decide between writing and math, and he decides to write. Tengo is my alter-ego from a different dimension. He chose writing just as I chose math. Thankfully math pays so I do not have to teach writing for a living.\nI’ve always loved writing. I have had several blogs representing different phrases of my life, each reflective of what I was going through at the time but haven’t maintained one of late for various inane excuses.\nI recently started reading The Artist’s Way and it inspired me to write again. I sometimes get stuck in arguments, trying to find reasons to justify doing or not doing something, analysis paralysis. Very simply though, I just enjoy putting thoughts into words, which is justification enough to write. I heard Neil Gaiman talk about how he likes to write with a fountain pen. Writing here is the equivalent of writing with a fountain pen for me - just watching words magically appear on the screen out of nowhere.\nThis journal is going to be a collection of my second drafts - nothing polished or well-thought but not stream-of-conscious either. As Sam Harris says, it’s never late to begin again.\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Second Drafts",
    "section": "",
    "text": "Barycentric Coordinates\n\n\n\naffine geometry\n\nobservablejs\n\ntriangles\n\ninteractive\n\nvisualization\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\n\n\n\n\n\nBegin Again\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2025\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "posts/barycentric coordinates.html",
    "href": "posts/barycentric coordinates.html",
    "title": "Barycentric Coordinates",
    "section": "",
    "text": "Show the code\nimport { Triangle, DraggableTriangle, Canvas, ShapeManager } from \"../scripts/triangle.js\";\n\n// === Observable view of canvas ===\nviewof canvas = {\n  const width = 800, height = 400;\n  const scale = 200, offset = [50, 250];\n  const canvasInstance = new Canvas(width, height, scale, offset);\n  const canvas = canvasInstance.getCanvas();\n  const ctx = canvasInstance.getContext();\n\n  // Add the canvas to the DOM\n  document.body.appendChild(canvas);\n\n  const A = [0, 0], B = [1, 0], C = [0, 1];\n  let A2 = [1.5, 0], B2 = [3, 0], C2 = [2, 1];\n\n  let target = { i: 0.3, j: 0.3 };\n  let current = { i: 0.3, j: 0.3 };\n  \n  // Shape manager to handle all shapes on the canvas\n  const shapeManager = new ShapeManager(canvasInstance);\n  \n  // Create triangles\n  const blackTri = canvasInstance.newTriangle(A, B, C);\n  const redTri = canvasInstance.newTriangle(A2, B2, C2, true);  // Draggable triangle\n\n  // Add triangles to shape manager\n  shapeManager.addShape(blackTri);\n  shapeManager.addShape(redTri);\n\n  // Handle drawing logic\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw black triangle and its grid\n    blackTri.drawGrid();\n    blackTri.draw({ fillStyle: \"rgba(0,0,0,0.2)\", strokeStyle: \"black\" });\n\n    // Draw red triangle and its grid\n    redTri.drawGrid();\n    redTri.draw({ strokeStyle: \"red\", vertexColor: \"red\" });\n\n    const k = 1 - current.i - current.j;\n    const [x, y] = blackTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([x, y], \"blue\");\n\n    const [gx, gy] = redTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([gx, gy], \"green\");\n\n    ctx.fillStyle = \"black\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(`i = ${current.i.toFixed(2)}, j = ${current.j.toFixed(2)}, k = ${k.toFixed(2)}`, 75, height - 100);\n    ctx.fillText(`x = ${gx.toFixed(2)}, y = ${gy.toFixed(2)}`, 420, height - 100);\n  }\n\n  // Animation loop for smooth transitions\n  function animate() {\n    const alpha = 0.2;\n    current.i += alpha * (target.i - current.i);\n    current.j += alpha * (target.j - current.j);\n    draw();\n    requestAnimationFrame(animate);\n  }\n\n  // Handle mouse interactions for triangle grid snapping\n  function handleMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const [x, y] = canvasInstance.fromCanvas([mx, my]);\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n    const snapTol = 0.05;\n    const vertices = [[1, 0], [0, 1], [0, 0]];\n    const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n    const minDist = Math.min(...dists);\n    if (minDist &lt; snapTol) {\n      [target.i, target.j] = vertices[dists.indexOf(minDist)];\n    } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n      target.i = bi;\n      target.j = bj;\n    }\n  }\n\n  // Handle dragging interaction on vertices\n  let draggingVertex = null;\n  function handleDrag(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    if (draggingVertex !== null) {\n      const newCoord = canvasInstance.fromCanvas([mx, my]);\n      if (draggingVertex === 0) A2 = newCoord;\n      else if (draggingVertex === 1) B2 = newCoord;\n      else if (draggingVertex === 2) C2 = newCoord;\n      redTri.A = A2;\n      redTri.B = B2;\n      redTri.C = C2;\n      draw();\n    } else {\n      handleMouse(e);\n    }\n  }\n\n  // Mouse down event for dragging vertices\n  canvas.addEventListener(\"mousedown\", e =&gt; {\n    const mx = e.clientX - canvas.getBoundingClientRect().left;\n    const my = e.clientY - canvas.getBoundingClientRect().top;\n    draggingVertex = null;\n\n    // Check which vertex is being dragged\n    [A2, B2, C2].forEach(([x, y], idx) =&gt; {\n      const [cx, cy] = canvasInstance.toCanvas([x, y]);\n      if (Math.hypot(mx - cx, my - cy) &lt; 10) draggingVertex = idx;\n    });\n\n    handleDrag(e);\n\n    // Attach move and up listeners to handle dragging\n    const move = e =&gt; handleDrag(e);\n    const up = () =&gt; {\n      draggingVertex = null;\n      window.removeEventListener(\"mousemove\", move);\n      window.removeEventListener(\"mouseup\", up);\n    };\n    window.addEventListener(\"mousemove\", move);\n    window.addEventListener(\"mouseup\", up);\n  });\n\n  // Start animation\n  requestAnimationFrame(animate);\n  return canvas;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBarycentric coordinates are a coordinate system for describing points within a triangle.\nFor a triangle with vertices \\(A\\), \\(B\\), and \\(C\\), any point \\(P\\) inside the triangle can be expressed as a weighted sum of the vertices: \\[\nP = iA + jB + kC\n\\] where \\(i\\), \\(j\\), and \\(k\\) are the barycentric coordinates, satisfying \\(i + j + k = 1\\) and \\(i, j, k \\geq 0\\). The barycentric coordinates can be interpreted as the relative areas of the sub-triangles formed with the point \\(P\\) and the vertices of the triangle.\nThere are many ways of seeing why this is true. Here’s one visual interpretation: First consider the triangle with vertices \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\). A point \\((x, y)\\) is inside this triangle exactly when: \\[\n0 \\le x, \\quad 0 \\le y, \\quad \\text{and} \\quad x + y \\le 1\n\\] In this case, we can write the point \\((x, y)\\) as: \\[\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n=\n(1 - x - y) \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} +\nx \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} +\ny \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n\\] So the barycentric coordinates of \\((x, y)\\) are \\((1 - x - y, x, y)\\), all of which are non-negative and sum to 1. Now all you need to do is map \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\) to the vertices of the triangle \\(A\\), \\(B\\), and \\(C\\), respectively, via an affine transformation. The barycentric coordinates of a point \\(P\\) inside the triangle with vertices \\(A\\), \\(B\\), and \\(C\\) are given by the same formula as above, with the standard triangle’s vertices replaced by \\(A\\), \\(B\\), and \\(C\\).\nYou can see this in the app above: move the blue point around the triangle and watch how the barycentric coordinates change. You can also move the vertices of the red triangle and observe how the coordinates adapt.\n\nThis post was an excuse for me to learn how to use ObservableJS. I was initially planning on using Python and Plotly, but Plotly is absurdly immature in terms of interactivity. Most of the code is generated by ChatGPT. I merely edited it to fit my needs.\n\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Posts",
      "Barycentric Coordinates"
    ]
  }
]