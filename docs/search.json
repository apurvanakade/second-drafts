[
  {
    "objectID": "posts/begin-again.html",
    "href": "posts/begin-again.html",
    "title": "Begin Again",
    "section": "",
    "text": "I opened this page with a clear idea of what I wanted to write. I’ve now spent the last half hour updating quarto, setting up a new git repository, fixing a git merge issue, figuring out how to render drafts… this was a mistake. When I have something to write, I need to get the words out as soon as possible without worrying about their final destination.\n\nOne of the protagonist in 1Q84, Tengo, is a writer. He teaches math at cram schools to make a living but his real passion is writing. At some point in his life he has to decide between writing and math, and he decides to write. Tengo is my alter-ego from a different dimension. He chose writing just as I chose math. Thankfully math pays so I do not have to teach writing for a living.\nI’ve always loved writing. I have had several blogs representing different phrases of my life, each reflective of what I was going through at the time but haven’t maintained one of late for various inane excuses.\nI recently started reading The Artist’s Way and it inspired me to write again. I sometimes get stuck in arguments, trying to find reasons to justify doing or not doing something, analysis paralysis. Very simply though, I just enjoy putting thoughts into words, which is justification enough to write. I heard Neil Gaiman talk about how he likes to write with a fountain pen. Writing here is the equivalent of writing with a fountain pen for me - just watching words magically appear on the screen out of nowhere.\nThis journal is going to be a collection of my second drafts - nothing polished or well-thought but not stream-of-conscious either. As Sam Harris says, it’s never late to begin again.\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Second Drafts",
    "section": "",
    "text": "Barycentric Coordinates\n\n\n\n\n\n\n\naffine geometry\n\n\nobservablejs\n\n\ntriangles\n\n\ninteractive\n\n\nvisualization\n\n\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\n\n\n\n\n\n\nBegin Again\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2025\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/barycentric coordinates.html",
    "href": "posts/barycentric coordinates.html",
    "title": "Barycentric Coordinates",
    "section": "",
    "text": "class Triangle {\n  constructor(A, B, C, canvasObj) {\n    this.A = A;\n    this.B = B;\n    this.C = C;\n    this.canvasObj = canvasObj;\n    this.ctx = canvasObj.getContext();\n    this.CanvasA = canvasObj.toCanvas(A);\n    this.CanvasB = canvasObj.toCanvas(B);\n    this.CanvasC = canvasObj.toCanvas(C);\n  }\n\n  toCanvas(p) {\n    return this.canvasObj.toCanvas(p);\n  }\n\n  fromCanvas(p) {\n    return this.canvasObj.fromCanvas(p);\n  }\n\n  draw({ fillStyle = null, strokeStyle = \"black\", vertexColor = null } = {}) {\n    const { CanvasA, CanvasB, CanvasC, ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(...CanvasA);\n    ctx.lineTo(...CanvasB);\n    ctx.lineTo(...CanvasC);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n    if (vertexColor) {\n      [this.CanvasA, this.CanvasB, this.CanvasC].forEach(([x, y]) =&gt; {\n        ctx.beginPath();\n        ctx.arc(x, y, 5, 0, 2 * Math.PI);\n        ctx.fillStyle = vertexColor;\n        ctx.fill();\n      });\n    }\n  }\n\n  drawGrid(spacing = 0.1, color = \"rgba(200,200,200,0.5)\") {\n    const { ctx } = this;\n    for (let i = 0; i &lt;= 1; i += spacing) {\n      for (let j = 0; j &lt;= 1 - i; j += spacing) {\n        const [x, y] = this.toCanvas(this.barycentricToCartesian(i, j));\n        const neighbors = [\n          [i + spacing, j],\n          [i, j + spacing],\n          [i + spacing, j - spacing]\n        ];\n        for (const [ni, nj] of neighbors) {\n          if (ni &gt;= 0 && nj &gt;= 0 && ni + nj &lt;= 1) {\n            const [x2, y2] = this.toCanvas(this.barycentricToCartesian(ni, nj));\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x2, y2);\n            ctx.strokeStyle = color;\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  }\n\n  barycentricToCartesian(i, j) {\n    const k = 1 - i - j;\n    return [\n      i * this.A[0] + j * this.B[0] + k * this.C[0],\n      i * this.A[1] + j * this.B[1] + k * this.C[1]\n    ];\n  }\n\n  cartesianToBarycentric(x, y) {\n    const [Ax, Ay] = this.A;\n    const [Bx, By] = this.B;\n    const [Cx, Cy] = this.C;\n    const v0 = [Bx - Ax, By - Ay];\n    const v1 = [Cx - Ax, Cy - Ay];\n    const v2 = [x - Ax, y - Ay];\n    const d00 = v0[0] * v0[0] + v0[1] * v0[1];\n    const d01 = v0[0] * v1[0] + v0[1] * v1[1];\n    const d11 = v1[0] * v1[0] + v1[1] * v1[1];\n    const d20 = v2[0] * v0[0] + v2[1] * v0[1];\n    const d21 = v2[0] * v1[0] + v2[1] * v1[1];\n    const denom = d00 * d11 - d01 * d01;\n    const j = (d11 * d20 - d01 * d21) / denom;\n    const k = (d00 * d21 - d01 * d20) / denom;\n    const i = 1 - j - k;\n    return [i, j];\n  }\n}\n\nclass DraggableTriangle extends Triangle {\n  constructor(A, B, C, canvasObj) {\n    super(A, B, C, canvasObj);\n    this.draggingIndex = null;\n  }\n\n  hitTest([mx, my], radius = 10) {\n    const points = [this.A, this.B, this.C];\n    return points.findIndex(([x, y]) =&gt; Math.hypot(mx - x, my - y) &lt; radius);\n  }\n\n  startDrag([mx, my]) {\n    this.draggingIndex = this.hitTest([mx, my]);\n    return this.draggingIndex !== -1;\n  }\n\n  dragTo([mx, my]) {\n    if (this.draggingIndex === null) return;\n    const newCoord = this.fromCanvas([mx, my]);\n    if (this.draggingIndex === 0) this.A = newCoord;\n    else if (this.draggingIndex === 1) this.B = newCoord;\n    else if (this.draggingIndex === 2) this.C = newCoord;\n\n    this.CanvasA = this.toCanvas(this.A);\n    this.CanvasB = this.toCanvas(this.B);\n    this.CanvasC = this.toCanvas(this.C);\n  }\n\n  endDrag() {\n    this.draggingIndex = null;\n  }\n}\n\nclass Canvas {\n  constructor(width, height, scale = 200, offset = [50, 250]) {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.scale = scale;\n    this.offset = offset;\n  }\n\n  getCanvas() {\n    return this.canvas;\n  }\n\n  getContext() {\n    return this.ctx;\n  }\n\n  toCanvas([x, y]) {\n    return [this.offset[0] + x * this.scale, this.offset[1] - y * this.scale];\n  }\n\n  fromCanvas([x, y]) {\n    return [(x - this.offset[0]) / this.scale, (this.offset[1] - y) / this.scale];\n  }\n\n  drawPoint([x, y], color = \"black\") {\n    const [canvasX, canvasY] = this.toCanvas([x, y]);\n    this.ctx.beginPath();\n    this.ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);\n    this.ctx.fillStyle = color;\n    this.ctx.fill();\n  }\n\n  newTriangle(A, B, C, draggable = false) {\n    return draggable\n      ? new DraggableTriangle(A, B, C, this)\n      : new Triangle(A, B, C, this);\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// === Observable viewof canvas ===\nviewof canvas = {\n  const width = 800, height = 400;\n  const scale = 200, offset = [50, 250];\n  const canvasInstance = new Canvas(width, height, scale, offset);\n  const canvas = canvasInstance.getCanvas();\n  const ctx = canvasInstance.getContext();\n\n  const A = [0, 0], B = [1, 0], C = [0, 1];\n  let A2 = [1.5, 0], B2 = [3, 0], C2 = [2, 1];\n\n  let target = { i: 0.3, j: 0.3 };\n  let current = { i: 0.3, j: 0.3 };\n  let draggingVertex = null;\n\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    blackTri.drawGrid();\n    blackTri.draw({ fillStyle: \"rgba(0,0,0,0.2)\", strokeStyle: \"black\" });\n\n    const redTri = canvasInstance.newTriangle(A2, B2, C2);\n    redTri.drawGrid();\n    redTri.draw({ strokeStyle: \"red\", vertexColor: \"red\" });\n\n    const k = 1 - current.i - current.j;\n    const [x, y] = blackTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([x, y], \"blue\");\n\n    const [gx, gy] = redTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([gx, gy], \"green\");\n\n    ctx.fillStyle = \"black\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(`i = ${current.i.toFixed(2)}, j = ${current.j.toFixed(2)}, k = ${k.toFixed(2)}`, 75, height - 100);\n    ctx.fillText(`x = ${gx.toFixed(2)}, y = ${gy.toFixed(2)}`, 420, height - 100);\n  }\n\n  function animate() {\n    const alpha = 0.2;\n    current.i += alpha * (target.i - current.i);\n    current.j += alpha * (target.j - current.j);\n    draw();\n    requestAnimationFrame(animate);\n  }\n\n  function handleMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const [x, y] = canvasInstance.fromCanvas([mx, my]);\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n    const snapTol = 0.05;\n    const vertices = [[1, 0], [0, 1], [0, 0]];\n    const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n    const minDist = Math.min(...dists);\n    if (minDist &lt; snapTol) {\n      [target.i, target.j] = vertices[dists.indexOf(minDist)];\n    } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n      target.i = bi;\n      target.j = bj;\n    }\n  }\n\n  function handleDrag(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    if (draggingVertex !== null) {\n      if (draggingVertex === 0) A2 = canvasInstance.fromCanvas([mx, my]);\n      else if (draggingVertex === 1) B2 = canvasInstance.fromCanvas([mx, my]);\n      else if (draggingVertex === 2) C2 = canvasInstance.fromCanvas([mx, my]);\n      draw();\n    } else {\n      handleMouse(e);\n    }\n  }\n\n  canvas.addEventListener(\"mousedown\", e =&gt; {\n    const mx = e.clientX - canvas.getBoundingClientRect().left;\n    const my = e.clientY - canvas.getBoundingClientRect().top;\n    draggingVertex = null;\n    [A2, B2, C2].forEach(([x, y], idx) =&gt; {\n      const [cx, cy] = canvasInstance.toCanvas([x, y]);\n      if (Math.hypot(mx - cx, my - cy) &lt; 10) draggingVertex = idx;\n    });\n\n    handleDrag(e);\n    const move = e =&gt; handleDrag(e);\n    const up = () =&gt; {\n      draggingVertex = null;\n      window.removeEventListener(\"mousemove\", move);\n      window.removeEventListener(\"mouseup\", up);\n    };\n    window.addEventListener(\"mousemove\", move);\n    window.addEventListener(\"mouseup\", up);\n  });\n\n  requestAnimationFrame(animate);\n  return canvas;\n}\n\n\n\n\n\n\nBarycentric coordinates are a coordinate system for describing points within a triangle.\nFor a triangle with vertices \\(A\\), \\(B\\), and \\(C\\), any point \\(P\\) inside the triangle can be expressed as a weighted sum of the vertices: \\[\nP = iA + jB + kC\n\\] where \\(i\\), \\(j\\), and \\(k\\) are the barycentric coordinates, satisfying \\(i + j + k = 1\\) and \\(i, j, k \\geq 0\\). The barycentric coordinates can be interpreted as the relative areas of the sub-triangles formed with the point \\(P\\) and the vertices of the triangle.\nThere are many ways of seeing why this is true. Here’s one visual interpretation: First consider the triangle with vertices \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\). A point \\((x, y)\\) is inside this triangle exactly when: \\[\n0 \\le x, \\quad 0 \\le y, \\quad \\text{and} \\quad x + y \\le 1\n\\] In this case, we can write the point \\((x, y)\\) as: \\[\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n=\n(1 - x - y) \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} +\nx \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} +\ny \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n\\] So the barycentric coordinates of \\((x, y)\\) are \\((1 - x - y, x, y)\\), all of which are non-negative and sum to 1. Now all you need to do is map \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\) to the vertices of the triangle \\(A\\), \\(B\\), and \\(C\\), respectively, via an affine transformation. The barycentric coordinates of a point \\(P\\) inside the triangle with vertices \\(A\\), \\(B\\), and \\(C\\) are given by the same formula as above, with the standard triangle’s vertices replaced by \\(A\\), \\(B\\), and \\(C\\).\nYou can see this in the app above: move the blue point around the triangle and watch how the barycentric coordinates change. You can also move the vertices of the red triangle and observe how the coordinates adapt.\n\nThis post was an excuse for me to learn how to use ObservableJS. I was initially planning on using Python and Plotly, but Plotly is absurdly immature in terms of interactivity. Most of the code is generated by ChatGPT. I merely edited it to fit my needs.\n\n\n\n\n Back to top"
  }
]