[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Second Drafts",
    "section": "",
    "text": "Sperner’s Lemma - Part 02\n\n\n\ncombinatorics\n\ntriangles\n\ncoloring\n\n\n\n\n\n\n\n\n\nMay 16, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nSperner’s Lemma - Part 01\n\n\n\ncombinatorics\n\ntriangles\n\ncoloring\n\nResearch\n\n\n\n\n\n\n\n\n\nMay 14, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nNon-Profits\n\n\n\n\n\n\n\n\nMay 13, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nRandom points in a triangle\n\n\n\nrandomness\n\ntriangles\n\nbarycentric coordinates\n\n\n\n\n\n\n\n\n\nMay 12, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nHopkins is a joke\n\n\n\n\n\n\n\n\nMay 12, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nBarycentric Coordinates\n\n\n\naffine geometry\n\nobservablejs\n\ntriangles\n\ninteractive\n\nvisualization\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nBegin Again\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2025\n\n\nApurva Nakade\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "9994-sperners-lemma-part-01.html",
    "href": "9994-sperners-lemma-part-01.html",
    "title": "Sperner’s Lemma - Part 01",
    "section": "",
    "text": "equilateral_triangle_vertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\n\n\n\n\n\n\n\nbarycentric_coords = {\n  let result = [];\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      result.push([i, j, N - i - j]);\n    }\n  }\n  return result;\n}\n\n\n\n\n\n\n\nclass ColoredPoint {\n  constructor(triple, equilateralTriangleVertices, N) {\n    this.barycentricTriple = triple;\n    const [A, B, C] = equilateralTriangleVertices;\n\n    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;\n    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;\n\n    this.color = this._assignColor(triple);\n  }\n\n  _assignColor(triple) {\n    const [a, b, c] = triple;\n\n    if (a === 0 && b === 0) return 'red';\n    if (b === 0 && c === 0) return 'green';\n    if (c === 0 && a === 0) return 'blue';\n\n    // pick randomly between red and blue\n    if (a === 0) return Math.random() &lt; 0.5 ? 'red' : 'blue';\n    if (b === 0) return Math.random() &lt; 0.5 ? 'red' : 'green';\n    if (c === 0) return Math.random() &lt; 0.5 ? 'blue' : 'green';\n\n    // pick randomly between red, green, and blue\n    return Math.random() &lt; 0.33 ? 'red' : (Math.random() &lt; 0.5 ? 'green' : 'blue');\n  }\n\n  getCoords() {\n    return { x: this.x, y: this.y };\n  }\n\n  getColor() {\n    return this.color;\n  }\n}\n\n\n\n\n\n\n\n// A cell to generate all ColoredPoint instances\n// and also create a map for efficient lookup.\n// This cell effectively replaces your `generateColoredPoints` function and the map creation.\ncoloredPointsMap = {\n  const coloredPoints = barycentric_coords.map(triple =&gt; {\n    return new ColoredPoint(triple, equilateral_triangle_vertices, N);\n  });\n\n  // Create a Map for quick lookup of colored_points by their barycentric triple\n  let coloredPointsMap = new Map();\n  for (const p of coloredPoints) {\n    coloredPointsMap.set(`${p.barycentricTriple[0]},${p.barycentricTriple[1]},${p.barycentricTriple[2]}`, p);\n  }\n\n  // Return both the array and the map\n  return { coloredPoints, coloredPointsMap };\n}\n\n\n\n\n\n\n\nsubTriangles = {\n  let triangles = [];\n  // upward facing triangles\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const coordinates = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const vertex_colors = new Set([\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()\n      ]);\n      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors\n    }\n  }\n  // downward facing triangles\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const coordinates = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const vertex_colors = new Set([\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()\n      ]);\n      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors\n    }\n  }\n  return triangles;\n}\n\n\n\n\n\n\n\nviewof plotEmpty = Plot.plot({\n  width: 800,\n  height: 800,\n  x: {\n    label: \"x\",\n    domain: [0, 1]\n  },\n  y: {\n    label: \"y\",\n    domain: [0, Math.sqrt(3) / 2]\n  },\n  marks: [\n    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {\n      x: \"x\",\n      y: \"y\",\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.dot(coloredPointsMap.coloredPoints, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.color,\n      r: 3\n    }),\n    Plot.geo(\n      {\n        type: \"FeatureCollection\",\n        features: subTriangles.map(triangle =&gt; {\n          let coords = triangle.coordinates.map(coord =&gt; coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());\n          return {\n            type: \"Feature\",\n            geometry: {\n              type: \"Polygon\",\n              coordinates: [\n                [coords[0], coords[1], coords[2], coords[0]].map(c =&gt; [c.x, c.y])\n              ]\n            },\n            properties: { // empty fill color\n              fillColor: \"none\",\n              coords: coords, // Store the coordinates\n              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array\n            }\n          };\n        })\n      },\n      {\n        fill: d =&gt; d.properties.fillColor, // Use the determined color.\n        stroke: \"black\",\n        strokeWidth: 1\n      }\n    ),\n    // Add the dots to show all colored points with their assigned color\n    Plot.dot(\n      coloredPointsMap.coloredPoints,\n      {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.color,\n        r: 5 // Slightly larger dots if desired\n      }\n    )\n  ]\n});\n\n\n\n\n\n\nSperner’s lemma is one of the first “non-trivial” theorems I remember hearing about at a summer camp in my high school. The theorem goes as follows. Consider a triangulation of a triangle. (Above we consider a regular triangulation of an equilateral triangle, but the theorem holds for any triangulation of a triangle.) We color the vertices of the triangle with three colors, say red, green and blue with the following conditions:\n\nThe vertices of the triangle are colored with the three colors: red, green, and blue.\nThe vertices that lie on the edges of the triangle are colored with one of the colors of the endpoints of that edge - this is crucial.\nThe vertices that lie in the interior of the triangle may be colored with any of the three colors.\n\nThe conditions 1, 2 are sometimes called the Sperner condition.\n\nTheorem 1 Any triangulation of a triangle satisfying Sperner’s condition has at least one “rainbow” triangle whose vertices are colored with all three colors red, green, and blue.\n\nWithout peeking below, can you how many rainbow (RGB) triangles are there in the above triangulation?\n\n\n\n\n\n// Determine the fill color based on the vertex colors.\ngetFillColorRGB = (vertexColors) =&gt; {\n  if (vertexColors.has('red') && vertexColors.has('green') && vertexColors.has('blue')) {\n    return 'black'; // Or any color you prefer for RGB triangles\n  } \n  return 'none'; // Default color\n};\n\n\n\n\n\n\n\nviewof plotRGB = Plot.plot({\n  width: 800,\n  height: 800,\n  x: {\n    label: \"x\",\n    domain: [0, 1]\n  },\n  y: {\n    label: \"y\",\n    domain: [0, Math.sqrt(3) / 2]\n  },\n  marks: [\n    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {\n      x: \"x\",\n      y: \"y\",\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.dot(coloredPointsMap.coloredPoints, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.color,\n      r: 3\n    }),\n    Plot.geo(\n      {\n        type: \"FeatureCollection\",\n        features: subTriangles.map(triangle =&gt; {\n          let coords = triangle.coordinates.map(coord =&gt; coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());\n          return {\n            type: \"Feature\",\n            geometry: {\n              type: \"Polygon\",\n              coordinates: [\n                [coords[0], coords[1], coords[2], coords[0]].map(c =&gt; [c.x, c.y])\n              ]\n            },\n            properties: { // Store the vertex colors for use in the fill\n              fillColor: getFillColorRGB(triangle.vertex_colors),\n              coords: coords, // Store the coordinates\n              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array\n            }\n          };\n        })\n      },\n      {\n        fill: d =&gt; d.properties.fillColor, // Use the determined color.\n        stroke: \"black\",\n        strokeWidth: 1\n      }\n    ),\n    // Add the dots to show all colored points with their assigned color\n    Plot.dot(\n      coloredPointsMap.coloredPoints,\n      {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.color,\n        r: 5 // Slightly larger dots if desired\n      }\n    )\n  ]\n});\n\n\n\n\n\n\n\nnumRGBTriangles = subTriangles.filter(triangle =&gt; triangle.vertex_colors.size === 3).length;\nhtml`&lt;p&gt;Number of RGB triangles: ${numRGBTriangles}&lt;/p&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI know a few proofs of this theorem, of varying levels of sophistication. I used to think I understood this theorem really well. And yet, I cannot predict the image below. Here, I’m coloring each triangle using the following mapping:\n\nRRR =&gt; red\nGGG =&gt; green\nBBB =&gt; blue\nRGG and RRG =&gt; yellow\nRBB and RRB =&gt; magenta\nGGB and GBB =&gt; cyan\nRGB =&gt; black\n\nWhen you learn abstract mathematics, it is easy to lose touch with the concrete. What is going on here? What patterns can you see? Why are there so many RGB triangles? What is the expected number of such triangles? What about the other colored triangles?\n\nimport {slider} from \"@jashkenas/inputs\"\n\n// Add a slider for M = number of points to plot\nviewof N = slider({\n  min: 2,\n  max: 20,\n  step: 1,\n  value: 5,\n  width: 500,\n  title: \"Number of subdivisions\"\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Determine the fill color based on the vertex colors.\ngetFillColorALL = (vertexColors) =&gt; {\n  if (vertexColors.has('red') && vertexColors.has('green') && vertexColors.has('blue')) {\n    return 'black'; // Or any color you prefer for RGB triangles\n  } else if (vertexColors.has('red') && vertexColors.has('green')) {\n    return 'yellow';\n  } else if (vertexColors.has('red') && vertexColors.has('blue')) {\n    return 'magenta';\n  } else if (vertexColors.has('green') && vertexColors.has('blue')) {\n    return 'cyan';\n  } else if (vertexColors.has('red')) {\n    return 'red';\n  } else if (vertexColors.has('green')) {\n    return 'green';\n  } else if (vertexColors.has('blue')) {\n    return 'blue';\n  }\n  return 'none'; // Default color\n};\n\n\n\n\n\n\n\nviewof plotALL = Plot.plot({\n  width: 800,\n  height: 800,\n  x: {\n    label: \"x\",\n    domain: [0, 1]\n  },\n  y: {\n    label: \"y\",\n    domain: [0, Math.sqrt(3) / 2]\n  },\n  marks: [\n    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {\n      x: \"x\",\n      y: \"y\",\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.dot(coloredPointsMap.coloredPoints, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.color,\n      r: 3\n    }),\n    Plot.geo(\n      {\n        type: \"FeatureCollection\",\n        features: subTriangles.map(triangle =&gt; {\n          let coords = triangle.coordinates.map(coord =&gt; coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());\n          return {\n            type: \"Feature\",\n            geometry: {\n              type: \"Polygon\",\n              coordinates: [\n                [coords[0], coords[1], coords[2], coords[0]].map(c =&gt; [c.x, c.y])\n              ]\n            },\n            properties: { // Store the vertex colors for use in the fill\n              fillColor: getFillColorALL(triangle.vertex_colors),\n              coords: coords, // Store the coordinates\n              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array\n            }\n          };\n        })\n      },\n      {\n        fill: d =&gt; d.properties.fillColor, // Use the determined color.\n        stroke: \"black\",\n        strokeWidth: 1\n      }\n    ),\n    // Add the dots to show all colored points with their assigned color\n    Plot.dot(\n      coloredPointsMap.coloredPoints,\n      {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.color,\n        r: 5 * (5 / N) // Decrease r as N increases\n      }\n    )\n  ]\n});\n\n\n\n\n\n\n\n// print the number of RGB triangles as a html element\nhtml`&lt;p&gt;Number of RGB triangles: ${numRGBTriangles}&lt;/p&gt;`\n\n\n\n\n\n\n\nRemark. Here’s a curious thing I discovered while drawing these colorful plots. How do you loop over all the sub-triangles in the triangulation? Think of an answer before peeking below.\n\n\n\n\nYou have to run two loops! One for the “upward-facing” triangles and one for the “downward-facing” ones. I don’t think there is any way to create a single loop for all these triangles.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Part 01"
    ]
  },
  {
    "objectID": "9997-hopkins-is-a-joke.html",
    "href": "9997-hopkins-is-a-joke.html",
    "title": "Hopkins is a joke",
    "section": "",
    "text": "It’s a crisp sunny day in the middle of way. We are deep into the final exam season. Everyone is stressed, sleep-deprived, over-caffeinated, over-worked. We have an exam for our course at 2 pm.\nWe arrive at the classroom to find it has a capacity of 150, and guess how many students we have in the class? 144. On the top of that, many of the chairs are broken. Oh and these are old, old chairs, fixed to the floor, tiny, uncomfortable - perfect for a 3 hour exam.\nProfessors have been complaining for years about outdated classrooms and what does Hopkins administration decide to do - build a new student center. The cherry on top is that the library is closed for “renovations” for ages now. So not only do we not have enough classrooms but students also do not have a place to study. Academics is clearly not a priority.\nThis is just the way of life here and we have gotten accustomed to it. But today, for something extra special, it being the finals week after all, there was a “Fire Alarm Test” DURING THE EXAM. Mind you, Hopkins really cares about it’s students - all the buildings are locked to provide quiet zones for students. So a fire alarm going on every 5 mins for an hour straight during the exam is totally fine. The administration has done their duty by posting “quite please” signs in the hallways. Now please donate to Hopkins so they can build a world class jacuzzi.\nWhat. A. Joke.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Hopkins is a joke"
    ]
  },
  {
    "objectID": "9996-random-points-in-a-triangle.html",
    "href": "9996-random-points-in-a-triangle.html",
    "title": "Random points in a triangle",
    "section": "",
    "text": "import {Plot} from \"@observablehq/plot\"\nimport {slider} from \"@jashkenas/inputs\"\n\nN = 1000\n\nunit_triangle = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0, y: 1},\n  {x: 0, y: 0}\n]\n\nequilateral_triangle = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0}\n]\n\n// Generate N random points in the unit square\n// and label them as \"Inside\" or \"Reflected points\"\nrandom_points = Array.from({length: N}, () =&gt; {\n  let x = Math.random();\n  let y = Math.random();\n  if (x + y &lt;= 1) {\n    return {x, y, label: \"Inside\"};\n  } else {\n    return {x, y, label: \"Reflected points\"};\n  }\n});\n\n\n// Reflect the points across the midpoint of the hypotenuse\nunit_triangle_points = random_points.map(d =&gt; {\n  if (d.label === \"Reflected points\") {\n    return {x: 1 - d.x, y: 1 - d.y, label: d.label};\n  } else {\n    return d;\n  }\n});\n\n// Transform the points to the equilateral triangle using barycentric coordinates\ntransformed_points = unit_triangle_points.map(d =&gt; {\n  const A = equilateral_triangle[0];\n  const B = equilateral_triangle[1];\n  const C = equilateral_triangle[2];\n  return {\n    x: d.x * A.x + d.y * B.x + (1 - d.x - d.y) * C.x,\n    y: d.x * A.y + d.y * B.y + (1 - d.x - d.y) * C.y,\n    label: d.label\n  };\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Add a slider for M = number of points to plot\nviewof M = slider({\n  min: 0,\n  max: N,\n  step: 1,\n  value: 100,\n  width: 500\n});\n\n\n\n\n\n\n\nviewof sideBySidePlots = {\n  // Create the title element\n  const title = document.createElement(\"h4\");\n  title.textContent = \"Generate points in a unit square, and reflect the points that lie above the hypotenuse\";\n  title.style.marginBottom = \"1em\";\n\n  // Create the first plot\n  const plot1 = Plot.plot({\n    width: 400,\n    height: 400,\n    x: {domain: [0, 1]},\n    y: {domain: [0, 1]},\n    marks: [\n      Plot.dot(random_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(unit_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0, y: 1}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Create the second plot\n  const plot2 = Plot.plot({\n    width: 400,\n    height: 400,\n    x: {domain: [0, 1]},\n    y: {domain: [0, 1]},\n    marks: [\n      Plot.dot(unit_triangle_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(unit_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0, y: 1}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Layout container\n  const container = document.createElement(\"div\");\n  container.style.display = \"flex\";\n  container.style.gap = \"20px\";\n\n  // Outer wrapper with title and plots\n  const wrapper = document.createElement(\"div\");\n  wrapper.append(title, container);\n  container.append(plot1, plot2);\n\n  return wrapper;\n}\n\n\n\n\n\n\n\n// Plot the first M points and center align it to the screen\nviewof centeredPlot = {\n  // Create the title element\n  const title = document.createElement(\"h4\");\n  title.textContent = \"Barycentric transformation to map unit triangle into equilateral triangle\";\n  title.style.marginBottom = \"1em\";\n\n  // Create the plot\n  const plot = Plot.plot({\n    width: 500,\n    height: 500,\n    x: {domain: [0, 1]},\n    y: {domain: [0, Math.sqrt(3) / 2]},\n    marks: [\n      Plot.dot(transformed_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(equilateral_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0.5, y: Math.sqrt(3) / 2}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Center the plot inside a container\n  const container = document.createElement(\"div\");\n  container.style.display = \"flex\";\n  container.style.flexDirection = \"column\";\n  container.style.alignItems = \"center\";\n  container.append(title, plot);\n\n  return container;\n}\n\n\n\n\n\n\nRandomness is a surprisingly hard thing to simulate. Any program, by definition has a predictable output. The best you can hope for is to predictably generate points that look random (pseudo-random) and fool some statistical tests. All random generation relies on two things:\n\na pseudo-random number generator that outputs a stream of numbers that “looks random”,\na mathematical function that converts uniform random variable(s) into random variables with other distributions.\n\nMathematicians are mostly interested in engineering Step 2. Step 1 is important, but is usually delegated to computer engineers.\nWith that preamble, here’s the question: Generate points randomly inside a triangle. I need this in order to play around with Sperner’s lemma examples.\nThe first step is to generate random points in the “standard triangle” with vertices \\([0, 0], [1, 0], [0, 1]\\). A very simple trick for this is to generate points in the unit square and “reflect the points” across the midpoint of the hypotenuse, \\([0.5, 0.5]\\). Next we use the barycentric transformation to transform the standard triangle into the desired triangle, in the above example, the equilateral triangle with vertices \\([0, 0], [1, 0], [0.5, \\sqrt{3}/2]\\).\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Random points in a triangle"
    ]
  },
  {
    "objectID": "9998-barycentric-coordinates.html",
    "href": "9998-barycentric-coordinates.html",
    "title": "Barycentric Coordinates",
    "section": "",
    "text": "class Triangle {\n  constructor(A, B, C, canvasObj) {\n    this.A = A;\n    this.B = B;\n    this.C = C;\n    this.canvasObj = canvasObj;\n    this.ctx = canvasObj.getContext();\n    this.CanvasA = canvasObj.toCanvas(A);\n    this.CanvasB = canvasObj.toCanvas(B);\n    this.CanvasC = canvasObj.toCanvas(C);\n  }\n\n  toCanvas(p) {\n    return this.canvasObj.toCanvas(p);\n  }\n\n  fromCanvas(p) {\n    return this.canvasObj.fromCanvas(p);\n  }\n\n  draw({ fillStyle = null, strokeStyle = \"black\", vertexColor = null } = {}) {\n    const { CanvasA, CanvasB, CanvasC, ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(...CanvasA);\n    ctx.lineTo(...CanvasB);\n    ctx.lineTo(...CanvasC);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n    if (vertexColor) {\n      [this.CanvasA, this.CanvasB, this.CanvasC].forEach(([x, y]) =&gt; {\n        ctx.beginPath();\n        ctx.arc(x, y, 5, 0, 2 * Math.PI);\n        ctx.fillStyle = vertexColor;\n        ctx.fill();\n      });\n    }\n  }\n\n  drawGrid(spacing = 0.1, color = \"rgba(200,200,200,0.5)\") {\n    const { ctx } = this;\n    for (let i = 0; i &lt;= 1; i += spacing) {\n      for (let j = 0; j &lt;= 1 - i; j += spacing) {\n        const [x, y] = this.toCanvas(this.barycentricToCartesian(i, j));\n        const neighbors = [\n          [i + spacing, j],\n          [i, j + spacing],\n          [i + spacing, j - spacing]\n        ];\n        for (const [ni, nj] of neighbors) {\n          if (ni &gt;= 0 && nj &gt;= 0 && ni + nj &lt;= 1) {\n            const [x2, y2] = this.toCanvas(this.barycentricToCartesian(ni, nj));\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x2, y2);\n            ctx.strokeStyle = color;\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  }\n\n  barycentricToCartesian(i, j) {\n    const k = 1 - i - j;\n    return [\n      i * this.A[0] + j * this.B[0] + k * this.C[0],\n      i * this.A[1] + j * this.B[1] + k * this.C[1]\n    ];\n  }\n\n  cartesianToBarycentric(x, y) {\n    const [Ax, Ay] = this.A;\n    const [Bx, By] = this.B;\n    const [Cx, Cy] = this.C;\n    const v0 = [Bx - Ax, By - Ay];\n    const v1 = [Cx - Ax, Cy - Ay];\n    const v2 = [x - Ax, y - Ay];\n    const d00 = v0[0] * v0[0] + v0[1] * v0[1];\n    const d01 = v0[0] * v1[0] + v0[1] * v1[1];\n    const d11 = v1[0] * v1[0] + v1[1] * v1[1];\n    const d20 = v2[0] * v0[0] + v2[1] * v0[1];\n    const d21 = v2[0] * v1[0] + v2[1] * v1[1];\n    const denom = d00 * d11 - d01 * d01;\n    const j = (d11 * d20 - d01 * d21) / denom;\n    const k = (d00 * d21 - d01 * d20) / denom;\n    const i = 1 - j - k;\n    return [i, j];\n  }\n}\n\nclass DraggableTriangle extends Triangle {\n  constructor(A, B, C, canvasObj) {\n    super(A, B, C, canvasObj);\n    this.draggingIndex = null;\n  }\n\n  hitTest([mx, my], radius = 10) {\n    const canvasPoints = [this.CanvasA, this.CanvasB, this.CanvasC];\n    return canvasPoints.findIndex(([x, y]) =&gt; Math.hypot(mx - x, my - y) &lt; radius);\n  }\n\n  startDrag([mx, my]) {\n    this.draggingIndex = this.hitTest([mx, my]);\n    return this.draggingIndex !== -1;\n  }\n\n  dragTo([mx, my]) {\n    if (this.draggingIndex === null) return;\n    const newCoord = this.fromCanvas([mx, my]);\n    if (this.draggingIndex === 0) this.A = newCoord;\n    else if (this.draggingIndex === 1) this.B = newCoord;\n    else if (this.draggingIndex === 2) this.C = newCoord;\n\n    this.CanvasA = this.toCanvas(this.A);\n    this.CanvasB = this.toCanvas(this.B);\n    this.CanvasC = this.toCanvas(this.C);\n  }\n\n  endDrag() {\n    this.draggingIndex = null;\n  }\n}\n\nclass Canvas {\n  constructor(width, height, scale = 200, offset = [50, 250]) {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.scale = scale;\n    this.offset = offset;\n  }\n\n  getCanvas() {\n    return this.canvas;\n  }\n\n  getContext() {\n    return this.ctx;\n  }\n\n  toCanvas([x, y]) {\n    return [this.offset[0] + x * this.scale, this.offset[1] - y * this.scale];\n  }\n\n  fromCanvas([x, y]) {\n    return [(x - this.offset[0]) / this.scale, (this.offset[1] - y) / this.scale];\n  }\n\n  drawPoint([x, y], color = \"black\") {\n    const [canvasX, canvasY] = this.toCanvas([x, y]);\n    this.ctx.beginPath();\n    this.ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);\n    this.ctx.fillStyle = color;\n    this.ctx.fill();\n  }\n\n  newTriangle(A, B, C, draggable = false) {\n    return draggable\n      ? new DraggableTriangle(A, B, C, this)\n      : new Triangle(A, B, C, this);\n  }\n}\n\n// === Observable viewof canvas ===\nviewof canvas = {\n  const width = 800, height = 400;\n  const scale = 200, offset = [50, 250];\n  const canvasInstance = new Canvas(width, height, scale, offset);\n  const canvas = canvasInstance.getCanvas();\n  const ctx = canvasInstance.getContext();\n\n  const A = [0, 0], B = [1, 0], C = [0, 1];\n  const redTri = canvasInstance.newTriangle([1.5, 0], [3, 0], [2, 1], true);\n\n  let target = { i: 0.3, j: 0.3 };\n  let current = { i: 0.3, j: 0.3 };\n\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    blackTri.drawGrid();\n    blackTri.draw({ fillStyle: \"rgba(0,0,0,0.2)\", strokeStyle: \"black\" });\n\n    redTri.drawGrid();\n    redTri.draw({ strokeStyle: \"red\", vertexColor: \"red\" });\n\n    const k = 1 - current.i - current.j;\n    const [x, y] = blackTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([x, y], \"blue\");\n\n    const [gx, gy] = redTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([gx, gy], \"green\");\n\n    ctx.fillStyle = \"black\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(`i = ${current.i.toFixed(2)}, j = ${current.j.toFixed(2)}, k = ${k.toFixed(2)}`, 75, height - 100);\n    ctx.fillText(`x = ${gx.toFixed(2)}, y = ${gy.toFixed(2)}`, 420, height - 100);\n  }\n\n  function animate() {\n    const alpha = 0.2;\n    current.i += alpha * (target.i - current.i);\n    current.j += alpha * (target.j - current.j);\n    draw();\n    requestAnimationFrame(animate);\n  }\n\n  function handleMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const [x, y] = canvasInstance.fromCanvas([mx, my]);\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n    const snapTol = 0.05;\n    const vertices = [[1, 0], [0, 1], [0, 0]];\n    const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n    const minDist = Math.min(...dists);\n    if (minDist &lt; snapTol) {\n      [target.i, target.j] = vertices[dists.indexOf(minDist)];\n    } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n      target.i = bi;\n      target.j = bj;\n    }\n  }\n\n  canvas.addEventListener(\"mousedown\", e =&gt; {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    if (redTri.startDrag([mx, my])) {\n      const move = e =&gt; {\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        redTri.dragTo([mx, my]);\n        draw();\n      };\n      const up = () =&gt; {\n        redTri.endDrag();\n        window.removeEventListener(\"mousemove\", move);\n        window.removeEventListener(\"mouseup\", up);\n      };\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", up);\n    } else {\n      // Start tracking movement to update target continuously\n      const move = e =&gt; {\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        const [x, y] = canvasInstance.fromCanvas([mx, my]);\n        const blackTri = canvasInstance.newTriangle(A, B, C);\n        const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n        const snapTol = 0.05;\n        const vertices = [[1, 0], [0, 1], [0, 0]];\n        const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n        const minDist = Math.min(...dists);\n        if (minDist &lt; snapTol) {\n          [target.i, target.j] = vertices[dists.indexOf(minDist)];\n        } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n          target.i = bi;\n          target.j = bj;\n        }\n      };\n      const up = () =&gt; {\n        window.removeEventListener(\"mousemove\", move);\n        window.removeEventListener(\"mouseup\", up);\n      };\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", up);\n    }\n  });\n\n  requestAnimationFrame(animate);\n  return canvas;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBarycentric coordinates are a coordinate system for describing points within a triangle.\nFor a triangle with vertices \\(A\\), \\(B\\), and \\(C\\), any point \\(P\\) inside the triangle can be expressed as a weighted sum of the vertices: \\[\nP = iA + jB + kC\n\\] where \\(i\\), \\(j\\), and \\(k\\) are the barycentric coordinates, satisfying \\(i + j + k = 1\\) and \\(i, j, k \\geq 0\\). The barycentric coordinates can be interpreted as the relative areas of the sub-triangles formed with the point \\(P\\) and the vertices of the triangle.\nThere are many ways of seeing why this is true. Here’s one visual interpretation: First consider the triangle with vertices \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\). A point \\((x, y)\\) is inside this triangle exactly when: \\[\n0 \\le x, \\quad 0 \\le y, \\quad \\text{and} \\quad x + y \\le 1\n\\] In this case, we can write the point \\((x, y)\\) as: \\[\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n=\n(1 - x - y) \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} +\nx \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} +\ny \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n\\] So the barycentric coordinates of \\((x, y)\\) are \\((1 - x - y, x, y)\\), all of which are non-negative and sum to 1. Now all you need to do is map \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\) to the vertices of the triangle \\(A\\), \\(B\\), and \\(C\\), respectively, via an affine transformation. The barycentric coordinates of a point \\(P\\) inside the triangle with vertices \\(A\\), \\(B\\), and \\(C\\) are given by the same formula as above, with the standard triangle’s vertices replaced by \\(A\\), \\(B\\), and \\(C\\).\nYou can see this in the app above: move the blue point around the triangle and watch how the barycentric coordinates change. You can also move the vertices of the red triangle and observe how the coordinates adapt.\n\nThis post was an excuse for me to learn how to use ObservableJS. I was initially planning on using Python and Plotly, but Plotly is absurdly immature in terms of interactivity. Most of the code is generated by ChatGPT. I merely edited it to fit my needs.\n\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Barycentric Coordinates"
    ]
  },
  {
    "objectID": "9999-begin-again.html",
    "href": "9999-begin-again.html",
    "title": "Begin Again",
    "section": "",
    "text": "I opened this page with a clear idea of what I wanted to write. I’ve now spent the last half hour updating quarto, setting up a new git repository, fixing a git merge issue, figuring out how to render drafts… this was a mistake. When I have something to write, I need to get the words out as soon as possible without worrying about their final destination.\n\nOne of the protagonist in 1Q84, Tengo, is a writer. He teaches math at cram schools to make a living but his real passion is writing. At some point in his life he has to decide between writing and math, and he decides to write. Tengo is my alter-ego from a different dimension. He chose writing just as I chose math. Thankfully math pays so I do not have to teach writing for a living.\nI’ve always loved writing. I have had several blogs representing different phrases of my life, each reflective of what I was going through at the time but haven’t maintained one of late for various inane excuses.\nI recently started reading The Artist’s Way and it inspired me to write again. I sometimes get stuck in arguments, trying to find reasons to justify doing or not doing something, analysis paralysis. Very simply though, I just enjoy putting thoughts into words, which is justification enough to write. I heard Neil Gaiman talk about how he likes to write with a fountain pen. Writing here is the equivalent of writing with a fountain pen for me - just watching words magically appear on the screen out of nowhere.\nThis journal is going to be a collection of my second drafts - nothing polished or well-thought but not stream-of-conscious either. As Sam Harris says, it’s never late to begin again.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Begin Again"
    ]
  },
  {
    "objectID": "9995-non-profits.html",
    "href": "9995-non-profits.html",
    "title": "Non-Profits",
    "section": "",
    "text": "My apartment complex in DC is having some landlord issues. Our landlord is a shady, dishonest guy whose main skill is not getting sued. He will do the absolute least he can to avoid being held liable. This post is not about him, though. This post is about some awesome people in DC.\nWe are having some legal issues with the landlord, and one of our fellow tenants reached out to some DC non-profits called Legal Aid DC and Housing Counseling Services. Some of their hardworking folks came to our apartment and talked to us about DC tenant laws, patiently answering all of our dumb questions. They spent their valuable time with us after a busy day and gave us the gift of time and knowledge – all of this at no cost! By the end of our meeting, we all breathed a sigh of relief – a big burden had been taken off our shoulders.\nI was touched by their generosity, and it made me greatly appreciate the value of non-profits. It made me appreciate how much impact small acts of kindness can have. I hope to be able to support these organizations somehow, but more importantly, to spread their message and spirit.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Non-Profits"
    ]
  },
  {
    "objectID": "9993-sperners-lemma-part-02.html",
    "href": "9993-sperners-lemma-part-02.html",
    "title": "Sperner’s Lemma - Part 02",
    "section": "",
    "text": "DRAFT DOCUMENT\n\nimport { slider } from \"@jashkenas/inputs\"\n\nviewof N = slider({\n  min: 2,\n  max: 25,\n  step: 1,\n  value: 15,\n  width: 500,\n  title: \"Number of subdivisions\"\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nequilateral_triangle_vertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\n\n\n\n\n\n\n\nbarycentric_coords = {\n  let result = [];\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      result.push([i, j, N - i - j]);\n    }\n  }\n  return result;\n}\n\n\n\n\n\n\n\ncentroid = (p1, p2, p3) =&gt; ({\n  x: (p1.x + p2.x + p3.x) / 3,\n  y: (p1.y + p2.y + p3.y) / 3\n});\n\n\n\n\n\n\n\nrandomChoice = (choices) =&gt; choices[Math.floor(Math.random() * choices.length)];\n\nclass ColoredPoint {\n  constructor(triple, vertices, N) {\n    this.barycentricTriple = triple;\n    const [A, B, C] = vertices;\n\n    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;\n    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;\n\n    this.color = this._assignColor(triple);\n  }\n\n  _assignColor([a, b, c]) {\n    if (a === 0 && b === 0) return 'red';\n    if (b === 0 && c === 0) return 'green';\n    if (c === 0 && a === 0) return 'blue';\n    if (a === 0) return randomChoice(['red', 'blue']);\n    if (b === 0) return randomChoice(['red', 'green']);\n    if (c === 0) return randomChoice(['green', 'blue']);\n    return randomChoice(['red', 'green', 'blue']);\n  }\n\n  getCoords() {\n    return { x: this.x, y: this.y };\n  }\n\n  getColor() {\n    return this.color;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncoloredPointsMap = {\n  const coloredPoints = barycentric_coords.map(triple =&gt;\n    new ColoredPoint(triple, equilateral_triangle_vertices, N)\n  );\n\n  const map = new Map();\n  for (const p of coloredPoints) {\n    map.set(p.barycentricTriple.join(','), p);\n  }\n\n  return { coloredPoints, coloredPointsMap: map };\n}\n\n\n\n\n\n\n\ngenerateTriangleData = (coordinates, cpMap) =&gt; {\n  const points = coordinates.map(coord =&gt; cpMap.get(coord.join(',')));\n  const colors = points.map(p =&gt; p.getColor());\n  const vertex_colors = new Set(colors);\n\n  let edges = [];\n  let special_points = [];\n\n  const computeMidpoint = (a, b) =&gt; {\n    const c1 = a.getCoords();\n    const c2 = b.getCoords();\n    return {\n      x: (c1.x + c2.x) / 2,\n      y: (c1.y + c2.y) / 2\n    };\n  };\n\n  const isSpecial = (a, b) =&gt; a.barycentricTriple[1] === 0 && b.barycentricTriple[1] === 0;\n\n  const RED = 'red', GREEN = 'green', BLUE = 'blue';\n\n  if (vertex_colors.has(RED) && vertex_colors.has(GREEN) && !vertex_colors.has(BLUE)) {\n    for (let k = 0; k &lt; 3; k++) {\n      const a = points[k], b = points[(k + 1) % 3];\n      if (colors[k] !== colors[(k + 1) % 3]) {\n        const midpoint = computeMidpoint(a, b);\n        edges.push(midpoint);\n        if (isSpecial(a, b)) special_points.push(midpoint);\n      }\n    }\n  }\n\n  if (vertex_colors.has(RED) && vertex_colors.has(GREEN) && vertex_colors.has(BLUE)) {\n    for (let k = 0; k &lt; 3; k++) {\n      const pairs = [\n        [k, (k + 1) % 3],\n        [k, (k + 2) % 3]\n      ];\n\n      for (const [i, j] of pairs) {\n        if (colors[i] === RED && colors[j] === GREEN) {\n          const a = points[i], b = points[j];\n          const midpoint = computeMidpoint(a, b);\n          edges.push(midpoint);\n          if (isSpecial(a, b)) special_points.push(midpoint);\n        }\n      }\n    }\n    const centroidPoint = centroid(...points.map(p =&gt; p.getCoords()));\n    edges.push(centroidPoint);\n    special_points.push(centroidPoint);\n  }\n\n  console.log(special_points);\n  return { coordinates, vertex_colors, edges, special_points };\n}\n\n\n\n\n\n\n\nsubTriangles = {\n  const triangles = [], trianglesRG = [], trianglesRGB = [];\n  const cpMap = coloredPointsMap.coloredPointsMap;\n\n  // Upward\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const coords = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const data = generateTriangleData(coords, cpMap);\n      triangles.push(data);\n      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {\n        data.vertex_colors.has('blue') ? trianglesRGB.push(data) : trianglesRG.push(data);\n      }\n    }\n  }\n\n  // Downward\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const coords = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const data = generateTriangleData(coords, cpMap);\n      triangles.push(data);\n      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {\n        data.vertex_colors.has('blue') ? trianglesRGB.push(data) : trianglesRG.push(data);\n      }\n    }\n  }\n\n  return { triangles, trianglesRG, trianglesRGB };\n}\n\n\n\n\n\n\n\nviewof plotALL = {\n  const cpMap = coloredPointsMap.coloredPointsMap;\n\n  const triangleFeatures = (triangles, fillColor) =&gt;\n    triangles.map(({ coordinates }) =&gt; {\n      const pts = coordinates.map(c =&gt; cpMap.get(c.join(',')).getCoords());\n      return {\n        type: \"Feature\",\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [[...pts, pts[0]].map(p =&gt; [p.x, p.y])]\n        },\n        properties: { fillColor }\n      };\n    });\n\n  const makeEdgeLines = triangles =&gt;\n    triangles.flatMap(tri =&gt;\n      tri.edges.map((pt, i, arr) =&gt; {\n        const next = arr[(i + 1) % arr.length];\n        return Plot.line([pt, next], {\n          x: \"x\",\n          y: \"y\",\n          stroke: \"black\",\n          strokeWidth: 5\n        });\n      })\n    );\n\n  const makeSpecialPoints = triangles =&gt;\n    triangles.flatMap(tri =&gt;\n      tri.special_points\n        .map(pt =&gt;\n          pt && pt.x !== undefined && pt.y !== undefined\n            ? Plot.dot([pt], { x: \"x\", y: \"y\", fill: \"white\", stroke: \"black\", r: 5 })\n            : null\n        )\n        .filter(Boolean)\n    );\n\n  const edgeLines = makeEdgeLines(subTriangles.trianglesRG);\n  const edgeLinesRGB = makeEdgeLines(subTriangles.trianglesRGB);\n  const special_pointsRG = makeSpecialPoints(subTriangles.trianglesRG);\n  const special_pointsRGB = makeSpecialPoints(subTriangles.trianglesRGB);\n\n  return Plot.plot({\n    width: 800,\n    height: 800,\n    x: { label: \"x\", domain: [0, 1] },\n    y: { label: \"y\", domain: [0, Math.sqrt(3) / 2] },\n    marks: [\n      Plot.geo(\n        { type: \"FeatureCollection\", features: triangleFeatures(subTriangles.triangles, \"white\") },\n        { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n      ),\n      Plot.geo(\n        { type: \"FeatureCollection\", features: triangleFeatures(subTriangles.trianglesRG, \"rgba(255, 215, 0, 0.7)\") },\n        { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n      ),\n      Plot.geo(\n        { type: \"FeatureCollection\", features: triangleFeatures(subTriangles.trianglesRGB, \"rgba(0, 0, 0, 0.25)\") },\n        { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n      ),\n      ...edgeLines,\n      ...edgeLinesRGB,\n      Plot.dot(\n        coloredPointsMap.coloredPoints.map(d =&gt; ({\n          ...d,\n          title: `(${d.barycentricTriple.join(\", \")})`\n        })),\n        {\n          x: \"x\",\n          y: \"y\",\n          fill: \"color\",\n          r: 5,\n          title: \"title\"\n        }\n      ),\n      ...special_pointsRG,\n      ...special_pointsRGB\n    ]\n  });\n}\n\n\n\n\n\n\nThis picture is the proof of Sperner’s Lemma.\nThink of each of the small triangles as a room with three walls. Here’s a weird trick — we think of each RG edge as being a door. Here’s the first interesting observation:\n\nRGB triangular rooms have only one door.\nRGG and RRG triangular rooms have two doors.\nAll other triangular rooms have no doors.\n\nThus, we already have a way to quantify RGB triangles — they are exactly the rooms with an odd number of doors. So, we can restate Sperner’s Lemma as saying:\n\nIf Sperner’s condition is satisfied, there must be at least one room with an odd number of doors.\n\nWe will prove a related version.\n\nImagine tracing all the possible paths in the triangular grid — the black paths in the diagram above are an example.\nThe yellow rooms have a path going across them from one RG door to another, while the RGB rooms have only one door to both enter and exit.\nHere are a few things you can immediately deduce using pure logic:\n\nNo two paths can intersect.\nSome paths are loops with no endpoints.\nThe paths that are not loops have exactly two endpoints. Hence, the total number of endpoints is even.\nEach endpoint can be exactly one of the following:\n\nAn RG door on the boundary of the original triangle.\n\nAn RGB triangular room.\n\n\n\nNote: The last statement is where we use Sperner’s condition.\n\nCombining these facts, we obtain the following result:\n\nTheorem 1 The sum of:\n\nthe number of RG edges on the boundary of the triangle, and\n\nthe number of RGB triangles\n\nmust be an even number.\n\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Part 02"
    ]
  }
]