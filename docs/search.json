[
  {
    "objectID": "9997-hopkins-is-a-joke.html",
    "href": "9997-hopkins-is-a-joke.html",
    "title": "Hopkins is a joke",
    "section": "",
    "text": "It’s a crisp sunny day in the middle of way. We are deep into the final exam season. Everyone is stressed, sleep-deprived, over-caffeinated, over-worked. We have an exam for our course at 2 pm.\nWe arrive at the classroom to find it has a capacity of 150, and guess how many students we have in the class? 144. On the top of that, many of the chairs are broken. Oh and these are old, old chairs, fixed to the floor, tiny, uncomfortable - perfect for a 3 hour exam.\nProfessors have been complaining for years about outdated classrooms and what does Hopkins administration decide to do - build a new student center. The cherry on top is that the library is closed for “renovations” for ages now. So not only do we not have enough classrooms but students also do not have a place to study. Academics is clearly not a priority.\nThis is just the way of life here and we have gotten accustomed to it. But today, for something extra special, it being the finals week after all, there was a “Fire Alarm Test” DURING THE EXAM. Mind you, Hopkins really cares about it’s students - all the buildings are locked to provide quiet zones for students. So a fire alarm going on every 5 mins for an hour straight during the exam is totally fine. The administration has done their duty by posting “quite please” signs in the hallways. Now please donate to Hopkins so they can build a world class jacuzzi.\nWhat. A. Joke.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Hopkins is a joke"
    ]
  },
  {
    "objectID": "9996-random-points-in-a-triangle.html",
    "href": "9996-random-points-in-a-triangle.html",
    "title": "Random points in a triangle",
    "section": "",
    "text": "import {Plot} from \"@observablehq/plot\"\nimport {slider} from \"@jashkenas/inputs\"\n\nN = 1000\n\nunit_triangle = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0, y: 1},\n  {x: 0, y: 0}\n]\n\nequilateral_triangle = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0}\n]\n\n// Generate N random points in the unit square\n// and label them as \"Inside\" or \"Reflected points\"\nrandom_points = Array.from({length: N}, () =&gt; {\n  let x = Math.random();\n  let y = Math.random();\n  if (x + y &lt;= 1) {\n    return {x, y, label: \"Inside\"};\n  } else {\n    return {x, y, label: \"Reflected points\"};\n  }\n});\n\n\n// Reflect the points across the midpoint of the hypotenuse\nunit_triangle_points = random_points.map(d =&gt; {\n  if (d.label === \"Reflected points\") {\n    return {x: 1 - d.x, y: 1 - d.y, label: d.label};\n  } else {\n    return d;\n  }\n});\n\n// Transform the points to the equilateral triangle using barycentric coordinates\ntransformed_points = unit_triangle_points.map(d =&gt; {\n  const A = equilateral_triangle[0];\n  const B = equilateral_triangle[1];\n  const C = equilateral_triangle[2];\n  return {\n    x: d.x * A.x + d.y * B.x + (1 - d.x - d.y) * C.x,\n    y: d.x * A.y + d.y * B.y + (1 - d.x - d.y) * C.y,\n    label: d.label\n  };\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Add a slider for M = number of points to plot\nviewof M = slider({\n  min: 0,\n  max: N,\n  step: 1,\n  value: 100,\n  width: 500\n});\n\n\n\n\n\n\n\nviewof sideBySidePlots = {\n  // Create the title element\n  const title = document.createElement(\"h4\");\n  title.textContent = \"Generate points in a unit square, and reflect the points that lie above the hypotenuse\";\n  title.style.marginBottom = \"1em\";\n\n  // Create the first plot\n  const plot1 = Plot.plot({\n    width: 400,\n    height: 400,\n    x: {domain: [0, 1]},\n    y: {domain: [0, 1]},\n    marks: [\n      Plot.dot(random_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(unit_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0, y: 1}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Create the second plot\n  const plot2 = Plot.plot({\n    width: 400,\n    height: 400,\n    x: {domain: [0, 1]},\n    y: {domain: [0, 1]},\n    marks: [\n      Plot.dot(unit_triangle_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(unit_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0, y: 1}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Layout container\n  const container = document.createElement(\"div\");\n  container.style.display = \"flex\";\n  container.style.gap = \"20px\";\n\n  // Outer wrapper with title and plots\n  const wrapper = document.createElement(\"div\");\n  wrapper.append(title, container);\n  container.append(plot1, plot2);\n\n  return wrapper;\n}\n\n\n\n\n\n\n\n// Plot the first M points and center align it to the screen\nviewof centeredPlot = {\n  // Create the title element\n  const title = document.createElement(\"h4\");\n  title.textContent = \"Barycentric transformation to map unit triangle into equilateral triangle\";\n  title.style.marginBottom = \"1em\";\n\n  // Create the plot\n  const plot = Plot.plot({\n    width: 500,\n    height: 500,\n    x: {domain: [0, 1]},\n    y: {domain: [0, Math.sqrt(3) / 2]},\n    marks: [\n      Plot.dot(transformed_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(equilateral_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0.5, y: Math.sqrt(3) / 2}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Center the plot inside a container\n  const container = document.createElement(\"div\");\n  container.style.display = \"flex\";\n  container.style.flexDirection = \"column\";\n  container.style.alignItems = \"center\";\n  container.append(title, plot);\n\n  return container;\n}\n\n\n\n\n\n\nRandomness is a surprisingly hard thing to simulate. Any program, by definition, has a predictable output. The best you can hope for is to predictably generate points that look random (pseudo-random) and fool some statistical tests. All random generation relies on two things:\n\nA pseudo-random number generator that outputs a stream of numbers that “looks random”\nA mathematical function that converts uniform random variable(s) into random variables with other distributions\n\nMathematicians are mostly interested in engineering Step 2. Step 1 is important but is usually delegated to computer engineers.\nWith that preamble, here’s the question: Generate points randomly inside a triangle. I need this in order to play around with Sperner’s lemma examples.\nThe first step is to generate random points in the “standard triangle” with vertices \\([0, 0], [1, 0], [0, 1]\\). A very simple trick for this is to generate points in the unit square and “reflect the points” across the midpoint of the hypotenuse, \\([0.5, 0.5]\\).\nNext, we use the barycentric transformation to transform the standard triangle into the desired triangle—in the example above, the equilateral triangle with vertices \\([0, 0], [1, 0], [0.5, \\sqrt{3}/2]\\).\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Random points in a triangle"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Second Drafts",
    "section": "",
    "text": "Bayes theorem\n\n\n\n\n\n\n\n\n\n\n\n\n\nSperner’s Lemma - Geometric Proof\n\n\n\ntriangles\n\ncoloring\n\nquestions\n\nvisualization\n\ninteractive\n\nobservablejs\n\ndeterminant\n\n\n\n\n\n\n\n\n\nMay 25, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nSperner’s Lemma - Combinatorial Proof\n\n\n\ncombinatorics\n\ntriangles\n\ncoloring\n\nvisualization\n\ninteractive\n\nobservablejs\n\nquestions\n\n\n\n\n\n\n\n\n\nMay 16, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nSperner’s Lemma - Statement\n\n\n\ncombinatorics\n\ntriangles\n\ncoloring\n\nquestions\n\nvisualization\n\ninteractive\n\nobservablejs\n\n\n\n\n\n\n\n\n\nMay 14, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nNon-Profits\n\n\n\n\n\n\n\n\nMay 13, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nRandom points in a triangle\n\n\n\nrandomness\n\ntriangles\n\nbarycentric coordinates\n\n\n\n\n\n\n\n\n\nMay 12, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nHopkins is a joke\n\n\n\n\n\n\n\n\nMay 12, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nBarycentric Coordinates\n\n\n\naffine geometry\n\nobservablejs\n\ntriangles\n\ninteractive\n\nvisualization\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nBegin Again\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2025\n\n\nApurva Nakade\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "9993-sperners-lemma-combinatorial-proof.html",
    "href": "9993-sperners-lemma-combinatorial-proof.html",
    "title": "Sperner’s Lemma - Combinatorial Proof",
    "section": "",
    "text": "import { slider } from \"@jashkenas/inputs\"\n\nviewof N = slider({\n  min: 2,\n  max: 25,\n  step: 1,\n  value: 15,\n  width: 500,\n  title: \"Number of subdivisions\"\n})\ncentroid = (p1, p2, p3) =&gt; ({\n  x: (p1.x + p2.x + p3.x) / 3,\n  y: (p1.y + p2.y + p3.y) / 3\n})\n\nmidpoint = (a, b) =&gt; {\n  const c1 = a.getCoords();\n  const c2 = b.getCoords();\n  return {\n    x: (c1.x + c2.x) / 2,\n    y: (c1.y + c2.y) / 2\n  };\n}\n\nisEdgeBoundary = (a, b) =&gt;\n  [0, 1, 2].some(i =&gt; a.barycentricTriple[i] === 0 && b.barycentricTriple[i] === 0)\n// === Triangle Generators ===\ngenerateBarycentricTriples = (N) =&gt; {\n  let result = [];\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      result.push([i, j, N - i - j]);\n    }\n  }\n  return result;\n}\nrandomChoice = (choices) =&gt; choices[Math.floor(Math.random() * choices.length)];\n\nclass ColoredPoint {\n  constructor(triple, vertices, N) {\n    this.barycentricTriple = triple;\n    const [A, B, C] = vertices;\n    const [a, b, c] = triple;\n\n    this.x = (a * A.x + b * B.x + c * C.x) / N;\n    this.y = (a * A.y + b * B.y + c * C.y) / N;\n\n    this.color = this._assignColor(a, b, c);\n  }\n\n  _assignColor(a, b, c) {\n    if (a === 0 && b === 0) return 'red';\n    if (b === 0 && c === 0) return 'green';\n    if (c === 0 && a === 0) return 'blue';\n    if (a === 0) return randomChoice(['red', 'blue']);\n    if (b === 0) return randomChoice(['red', 'green']);\n    if (c === 0) return randomChoice(['green', 'blue']);\n    return randomChoice(['red', 'green', 'blue']);\n  }\n\n  getCoords() {\n    return { x: this.x, y: this.y };\n  }\n\n  getColor() {\n    return this.color;\n  }\n}\ngetTrianglePoints = (coords, cpMap) =&gt;\n  coords.map(coord =&gt; cpMap.get(coord.join(',')));\n\ngetTriangleColors = (points) =&gt;\n  points.map(p =&gt; p.getColor());\n\nclassifyTriangle = (vertexColors) =&gt; {\n  const set = new Set(vertexColors);\n  return {\n    isRG: set.has('red') && set.has('green') && !set.has('blue'),\n    isRGB: set.has('red') && set.has('green') && set.has('blue'),\n    vertexColors: set\n  }\n}\n\ngetTriangleEdges = (points, classification) =&gt; {\n  const edges = [];\n\n  if (classification.isRG) {\n    for (let k = 0; k &lt; 3; k++) {\n      const a = points[k], b = points[(k + 1) % 3];\n      if (a.getColor() !== b.getColor()) {\n        edges.push({ point: midpoint(a, b), source: [a, b] });\n      }\n    }\n  }\n\n  if (classification.isRGB) {\n    for (let k = 0; k &lt; 3; k++) {\n      const pairs = [[k, (k + 1) % 3], [k, (k + 2) % 3]];\n      for (const [i, j] of pairs) {\n        if (points[i].getColor() === 'red' && points[j].getColor() === 'green') {\n          edges.push({ point: midpoint(points[i], points[j]), source: [points[i], points[j]] });\n        }\n      }\n    }\n    edges.push({ point: centroid(...points.map(p =&gt; p.getCoords())), source: null });\n  }\n\n  return edges;\n}\n\ngetSpecialPoints = (edges, classification) =&gt; {\n  const specials = [];\n\n  for (const edge of edges) {\n    const [a, b] = edge.source || [];\n    if (a && b && isEdgeBoundary(a, b)) {\n      specials.push(edge.point);\n    }\n  }\n\n  // Always include centroid for RGB triangles\n  if (classification.isRGB) {\n    const centroidEdge = edges.find(e =&gt; e.source === null);\n    if (centroidEdge) specials.push(centroidEdge.point);\n  }\n\n  return specials;\n}\n\ngenerateTriangleData = (coordinates, cpMap) =&gt; {\n  const points = coordinates.map(coord =&gt; cpMap.get(coord.join(',')));\n  \n  const colors = points.map(p =&gt; p.getColor());\n  const vertex_colors = new Set(colors);\n  const classification = classifyTriangle(vertex_colors);\n  const edgesWithSource = getTriangleEdges(points, classification);\n  const special_points = getSpecialPoints(edgesWithSource, classification);\n\n  return {\n    coordinates,\n    vertex_colors,\n    classification,\n    edges: edgesWithSource.map(e =&gt; e.point),\n    special_points\n  };\n}\ntriangleFeatures = (triangles, cpMap, fillColor) =&gt;\n  triangles.map(({ coordinates }) =&gt; {\n    const pts = coordinates.map(c =&gt; cpMap.get(c.join(',')).getCoords());\n    return {\n      type: \"Feature\",\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [[...pts, pts[0]].map(p =&gt; [p.x, p.y])]\n      },\n      properties: { fillColor }\n    };\n  });\n\nmakeEdgeLines = (triangles) =&gt;\n  triangles.flatMap(tri =&gt;\n    tri.edges.map((pt, i, arr) =&gt; {\n      const next = arr[(i + 1) % arr.length];\n      return Plot.line([pt, next], {\n        x: \"x\",\n        y: \"y\",\n        stroke: \"black\",\n        strokeWidth: 5\n      });\n    })\n  );\n\nmakeSpecialPoints = (triangles) =&gt;\n  triangles.flatMap(tri =&gt;\n    tri.special_points\n      .map(pt =&gt;\n        pt && pt.x !== undefined && pt.y !== undefined\n          ? Plot.dot([pt], { x: \"x\", y: \"y\", fill: \"white\", stroke: \"black\", r: 4 })\n          : null\n      )\n      .filter(Boolean)\n  );\n// === Define Base Triangle Vertices ===\nvertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\ntriples = generateBarycentricTriples(N);\n\ncoloredPoints = triples.map(triple =&gt;\n  new ColoredPoint(triple, vertices, N)\n);\n\ncpMap = new Map(coloredPoints.map(p =&gt; [p.barycentricTriple.join(','), p]));\ngenerateAllTriangles = (N, cpMap) =&gt; {\n  const all = [], rg = [], rgb = [];\n\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const up = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const data = generateTriangleData(up, cpMap);\n      all.push(data);\n      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {\n        data.vertex_colors.has('blue') ? rgb.push(data) : rg.push(data);\n      }\n    }\n  }\n\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const down = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const data = generateTriangleData(down, cpMap);\n      all.push(data);\n      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {\n        data.vertex_colors.has('blue') ? rgb.push(data) : rg.push(data);\n      }\n    }\n  }\n\n  return { all, rg, rgb };\n}\n\ntriangles = generateAllTriangles(N, cpMap);\n// === Final Plot ===\nviewof plotAll = Plot.plot({\n  width: 800,\n  height: 800,\n  x: { label: \"x\", domain: [0, 1] },\n  y: { label: \"y\", domain: [0, Math.sqrt(3) / 2] },\n  marks: [\n    Plot.geo(\n      { type: \"FeatureCollection\", features: triangleFeatures(triangles.all, cpMap, \"white\") },\n      { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n    ),\n    Plot.geo(\n      { type: \"FeatureCollection\", features: triangleFeatures(triangles.rg, cpMap, \"rgba(255, 215, 0, 0.7)\") },\n      { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n    ),\n    Plot.geo(\n      { type: \"FeatureCollection\", features: triangleFeatures(triangles.rgb, cpMap, \"rgba(0, 0, 0, 0.25)\") },\n      { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n    ),\n    ...makeEdgeLines(triangles.rg),\n    ...makeEdgeLines(triangles.rgb),\n    Plot.dot(\n      coloredPoints.map(d =&gt; ({\n        ...d,\n        title: `(${d.barycentricTriple.join(\", \")})`\n      })),\n      {\n        x: \"x\",\n        y: \"y\",\n        fill: \"color\",\n        r: 4,\n        title: \"title\"\n      }\n    ),\n    ...makeSpecialPoints(triangles.rg),\n    ...makeSpecialPoints(triangles.rgb)\n  ]\n});\nThis picture is a combinatorial proof of Sperner’s Lemma.\nImagine each small triangle as a room with three walls. Next we do a trick that I do not know how to motivate: treat each RG edge as a door. Here’s what we observe:\n// Create an SVG and draw three triangles with vertex colors and bold RG edges\n\nsvg = {\n  const width = 600, height = 200;\n  const svg = DOM.svg(width, height);\n  svg.setAttribute(\"width\", width);\n  svg.setAttribute(\"height\", height);\n  svg.style.background = \"#fff\";\n\n  // Triangle definitions: each vertex has [x, y, color]\n  const triangles = [\n    {\n      vertices: [\n        [50, 150, \"red\"],\n        [100, 50, \"green\"],\n        [150, 150, \"blue\"]\n      ],\n      fill: \"lightgray\",\n      label: \"RGB\"\n    },\n    {\n      vertices: [\n        [250, 150, \"red\"],\n        [300, 50, \"red\"],\n        [350, 150, \"green\"]\n      ],\n      fill: \"rgba(255, 215, 0, 1)\",\n      label: \"RRG\"\n    },\n    {\n      vertices: [\n        [450, 150, \"red\"],\n        [500, 50, \"green\"],\n        [550, 150, \"green\"]\n      ],\n      fill: \"rgba(255, 215, 0, 1)\",\n      label: \"RGG\"\n    }\n  ];\n\n  for (const {vertices, fill, label} of triangles) {\n    // Draw triangle fill\n    const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n    polygon.setAttribute(\"points\", vertices.map(v =&gt; `${v[0]},${v[1]}`).join(\" \"));\n    polygon.setAttribute(\"fill\", fill);\n    polygon.setAttribute(\"stroke\", \"black\");\n    polygon.setAttribute(\"stroke-width\", \"1\");\n    svg.appendChild(polygon);\n\n    // Draw edges with RG edges bolded\n    for (let i = 0; i &lt; 3; i++) {\n      const [x1, y1, c1] = vertices[i];\n      const [x2, y2, c2] = vertices[(i + 1) % 3];\n\n      const isRG = (c1 === \"red\" && c2 === \"green\") || (c1 === \"green\" && c2 === \"red\");\n\n      const edge = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      edge.setAttribute(\"x1\", x1);\n      edge.setAttribute(\"y1\", y1);\n      edge.setAttribute(\"x2\", x2);\n      edge.setAttribute(\"y2\", y2);\n      edge.setAttribute(\"stroke\", \"black\");\n      edge.setAttribute(\"stroke-width\", isRG ? \"4\" : \"1\");\n      if (isRG) edge.setAttribute(\"stroke-dasharray\", \"8,4\"); // dotted line\n      svg.appendChild(edge);\n    }\n\n    // Draw vertices with colors\n    for (const [x, y, color] of vertices) {\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", x);\n      circle.setAttribute(\"cy\", y);\n      circle.setAttribute(\"r\", 4);\n      circle.setAttribute(\"fill\", color);\n      svg.appendChild(circle);\n    }\n\n    // Add label\n    const [lx, ly] = vertices[1]; // top vertex\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute(\"x\", lx);\n    text.setAttribute(\"y\", ly - 10);\n    text.setAttribute(\"text-anchor\", \"middle\");\n    text.setAttribute(\"font-size\", \"12\");\n    text.setAttribute(\"font-family\", \"sans-serif\");\n    text.textContent = label;\n    svg.appendChild(text);\n  }\n\n  return svg;\n}\nIn other words, we can identify RGB triangles as the rooms with an odd number of doors. Sperner’s Lemma, then, can be restated in a more visual way: If Sperner’s condition holds, there is at least one room with an odd number of doors. We’ll prove a related version of this statement.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Combinatorial Proof"
    ]
  },
  {
    "objectID": "9993-sperners-lemma-combinatorial-proof.html#following-the-doors",
    "href": "9993-sperners-lemma-combinatorial-proof.html#following-the-doors",
    "title": "Sperner’s Lemma - Combinatorial Proof",
    "section": "Following the Doors",
    "text": "Following the Doors\nPicture all the possible paths that can be formed by stepping through these RG doors — the black lines in the diagram represent all of these paths.\n\nThe yellow triangles have paths that enter through one door and exit through another — like hallways.\n\nThe RGB triangles have only one door, so they are endpoints — there’s no way to pass through.\n\nUsing simple logic, we can deduce the following:\n\nNo two paths intersect.\n\nSome paths form closed loops.\n\nPaths that do not form loops must have two endpoints, so the total number of endpoints is even.\n\nThe only possible endpoints are:\n\nAn RG door on the outer boundary of the big triangle\nAn RGB triangle.\n\n\nPutting this all together gives us a key result:\n\nTheorem 1 The sum of the number of RG boundary edges, and the number of RGB triangles must be even.\n\nFrom this, we immediately get:\n\nTheorem 2 The number of RGB triangles is odd if and only if the number of RG edges on the boundary is odd.\n\nSo to conclude the proof, all that remains is to show:\n\nConjecture 1 The number of RG boundary edges is odd.\n\nSperner’s condition implies that the only RG boundary edges must appear on the bottom edge, which reduces the problem to the following.\n\nConjecture 2 The number of RG boundary edges on the bottom edge is odd.\n\nThis is indeed a true statement and can be proven by various simple but subtle tricks. Give it a shot! Be careful though, it is easy to convince yourself that you have a proof when you don’t.\n \n\nviewof M = slider({\n  min: 1,\n  max: 25,\n  step: 1,\n  value: 5,\n  width: 500,\n  title: \"Number of subdivisions\"\n})\n\n\n\n\n\n\n\nviewof plot = {\n  const colors = Array.from({length: M + 1}, (_, i) =&gt; {\n    if (i === 0) return \"red\";\n    if (i === M) return \"green\";\n    return Math.random() &lt; 0.5 ? \"red\" : \"green\";\n  });\n  const x = d3.scaleLinear().domain([0, M]).range([20, 580]);\n  const svg = d3.create(\"svg\").attr(\"width\", 600).attr(\"height\", 100);\n  let boldCount = 0;\n\n  for (let i = 0; i &lt; M; i++) {\n    const c1 = colors[i], c2 = colors[i + 1];\n    const bold = c1 !== c2;\n    if (bold) boldCount++;\n    svg.append(\"line\")\n      .attr(\"x1\", x(i)).attr(\"x2\", x(i + 1))\n      .attr(\"y1\", 50).attr(\"y2\", 50)\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-width\", bold ? 6 : 1);\n  }\n\n  svg.selectAll(\"circle\")\n    .data(colors)\n    .join(\"circle\")\n    .attr(\"cx\", (_, i) =&gt; x(i))\n    .attr(\"cy\", 50)\n    .attr(\"r\", 5)\n    .attr(\"fill\", d =&gt; d)\n    .attr(\"stroke\", \"black\");\n\n  svg.append(\"text\")\n    .attr(\"x\", 150).attr(\"y\", 15)\n    .text(`Number of RG edges: ${boldCount}`)\n    .attr(\"font-size\", 20);\n\n  return svg.node();\n}",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Combinatorial Proof"
    ]
  },
  {
    "objectID": "9993-sperners-lemma-combinatorial-proof.html#questions",
    "href": "9993-sperners-lemma-combinatorial-proof.html#questions",
    "title": "Sperner’s Lemma - Combinatorial Proof",
    "section": "Questions",
    "text": "Questions\nThe app at the top of this page demonstrates the proof by dividing a triangle uniformly into smaller triangles. However, Sperner’s Lemma is much more general: it applies to any triangulation of a triangle, as long as the vertices are colored according to Sperner’s condition. The proof itself never relies on the triangulation being uniform — so it holds for any triangulation. That said, the app is harder to generalize for arbitrary triangulations.\n\nHow does one generate random triangulations?\n\nOne natural approach is to use Delaunay triangulations, but how random are these triangulations? Once you have such a triangulation, the next step is:\n\nHow do you efficiently loop through all the triangles?\n\nWhile this isn’t a research question, implementing a general Sperner’s Lemma checker on arbitrary triangulations would be a neat exercise, combining computational geometry with combinatorics.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Combinatorial Proof"
    ]
  },
  {
    "objectID": "9999-begin-again.html",
    "href": "9999-begin-again.html",
    "title": "Begin Again",
    "section": "",
    "text": "I opened this page with a clear idea of what I wanted to write. I’ve now spent the last half hour updating quarto, setting up a new git repository, fixing a git merge issue, figuring out how to render drafts… this was a mistake. When I have something to write, I need to get the words out as soon as possible without worrying about their final destination.\n\nOne of the protagonist in 1Q84, Tengo, is a writer. He teaches math at cram schools to make a living but his real passion is writing. At some point in his life he has to decide between writing and math, and he decides to write. Tengo is my alter-ego from a different dimension. He chose writing just as I chose math. Thankfully math pays so I do not have to teach writing for a living.\nI’ve always loved writing. I have had several blogs representing different phrases of my life, each reflective of what I was going through at the time but haven’t maintained one of late for various inane excuses.\nI recently started reading The Artist’s Way and it inspired me to write again. I sometimes get stuck in arguments, trying to find reasons to justify doing or not doing something, analysis paralysis. Very simply though, I just enjoy putting thoughts into words, which is justification enough to write. I heard Neil Gaiman talk about how he likes to write with a fountain pen. Writing here is the equivalent of writing with a fountain pen for me - just watching words magically appear on the screen out of nowhere.\nThis journal is going to be a collection of my second drafts - nothing polished or well-thought but not stream-of-conscious either. As Sam Harris says, it’s never late to begin again.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Begin Again"
    ]
  },
  {
    "objectID": "9995-non-profits.html",
    "href": "9995-non-profits.html",
    "title": "Non-Profits",
    "section": "",
    "text": "My apartment complex in DC is having some landlord issues. Our landlord is a shady, dishonest guy whose main skill is not getting sued. He will do the absolute least he can to avoid being held liable. This post is not about him, though. This post is about some awesome people in DC.\nWe are having some legal issues with the landlord, and one of our fellow tenants reached out to some DC non-profits called Legal Aid DC and Housing Counseling Services. Some of their hardworking folks came to our apartment and talked to us about DC tenant laws, patiently answering all of our dumb questions. They spent their valuable time with us after a busy day and gave us the gift of time and knowledge – all of this at no cost! By the end of our meeting, we all breathed a sigh of relief – a big burden had been taken off our shoulders.\nI was touched by their generosity, and it made me greatly appreciate the value of non-profits. It made me appreciate how much impact small acts of kindness can have. I hope to be able to support these organizations somehow, but more importantly, to spread their message and spirit.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Non-Profits"
    ]
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html",
    "href": "9992-sperners-lemma-geometric-proof.html",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "",
    "text": "This is my new favorite proof of Sperner’s lemma. In the following app the vertices are slowly morphed to the “cardinal” R, G, B vertices with time while preserving the adjacency relations. The red triangles are oriented counter-clockwise and the blue triangles are oriented clockwise. Can you come up with the proof yourself without peeking below? You can try reducing the number of subdivisions to get a sense of what’s going on.\nimport {slider} from \"@jashkenas/inputs\"\nequilateralTriangleVertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n];\n\ngenerateBarycentricCoords = N =&gt; {\n  const coords = []\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      coords.push([i, j, N - i - j])\n    }\n  }\n  return coords\n};\n\npickRandomColor = (...options) =&gt; options[Math.floor(Math.random() * options.length)];\n\nsmoothstepEase = t =&gt; 6 * t ** 5 - 15 * t ** 4 + 10 * t ** 3;\ndefaultAssignColor = (a, b, c) =&gt; {\n  if (a === 0 && b === 0) return 'red'\n  if (b === 0 && c === 0) return 'green'\n  if (c === 0 && a === 0) return 'blue'\n  if (a === 0) return pickRandomColor('red', 'blue')\n  if (b === 0) return pickRandomColor('red', 'green')\n  if (c === 0) return pickRandomColor('blue', 'green')\n  return pickRandomColor('red', 'green', 'blue')\n}\n\nsimplerAssignColor = (a, b, c) =&gt; {\n  if (a === 0 && b === 0) return 'red'\n  if (b === 0 && c === 0) return 'green'\n  if (c === 0 && a === 0) return 'blue'\n  return pickRandomColor('red', 'green', 'blue')\n}\nfunction createTriangleMorpher(N, vertices, assignColor, easing = smoothstepEase) {\n  const baryCoords = generateBarycentricCoords(N)\n\n  const buildColorMap = () =&gt; {\n    const map = new Map()\n    for (const [a, b, c] of baryCoords) {\n      map.set(`${a},${b},${c}`, assignColor(a, b, c))\n    }\n    return map\n  }\n\n  const interpolatePoints = (t, colorMap) =&gt; {\n    const [A, B, C] = vertices\n    const vertexMap = { red: C, green: A, blue: B }\n    const s = easing(t)\n\n    const morphedPoints = baryCoords.map(([a, b, c]) =&gt; {\n      const sum = a + b + c\n      const x0 = (a * A.x + b * B.x + c * C.x) / sum\n      const y0 = (a * A.y + b * B.y + c * C.y) / sum\n\n      const color = colorMap.get(`${a},${b},${c}`)\n      const target = vertexMap[color]\n\n      return {\n        x: (1 - s) * x0 + s * target.x,\n        y: (1 - s) * y0 + s * target.y,\n        color,\n        barycentricTriple: [a, b, c]\n      }\n    })\n\n    const morphedMap = new Map(morphedPoints.map(p =&gt; [p.barycentricTriple.join(','), p]))\n    return { morphedPoints, morphedMap }\n  }\n\n  const generateSubTriangles = morphedMap =&gt; {\n    const triangles = []\n    for (let i = 0; i &lt; N; i++) {\n      for (let j = 0; j &lt; N - i; j++) {\n        const a = [i, j, N - i - j]\n        const b = [i + 1, j, N - i - j - 1]\n        const c = [i, j + 1, N - i - j - 1]\n        triangles.push({ coordinates: [a, b, c] })\n\n        if (i + j &lt; N - 1) {\n          const d = [i + 1, j + 1, N - i - j - 2]\n          triangles.push({ coordinates: [b, d, c] })\n        }\n      }\n    }\n\n    return triangles.map(tri =&gt; {\n      const vertex_colors = tri.coordinates.map(c =&gt; morphedMap.get(c.join(',')).color)\n      return { ...tri, vertex_colors }\n    })\n  }\n\n  return {\n    baryCoords,\n    buildColorMap,\n    interpolatePoints,\n    generateSubTriangles\n  }\n}\nfillColorGroups = {\n  const group1 = new Set(['RGB', 'GBR', 'BRG'])\n  const group2 = new Set(['RBG', 'BGR', 'GRB'])\n  return { group1, group2 }\n}\n\ngetFillColor = vertexColors =&gt; {\n  const map = { red: 'R', green: 'G', blue: 'B' }\n  const key = vertexColors.map(c =&gt; map[c.toLowerCase()] || '').join('')\n\n  if (fillColorGroups.group1.has(key)) {\n    return 'rgba(255, 99, 71, 0.5)' // Tomato\n  }\n\n  if (fillColorGroups.group2.has(key)) {\n    return 'rgba(72, 209, 204, 0.5)' // Medium turquoise\n  }\n\n  // Neutral group (fallback): soft gray\n  return 'rgba(160, 160, 160, 0.25)'\n}\nfunction plotTriangles(triangles, morphedPoints, vertices) {\n  return Plot.plot({\n    width: 800,\n    height: 800,\n    margin: 40,  // Add padding around the chart\n    x: {domain: [0, 1], axis: null},\n    y: {domain: [0, Math.sqrt(3) / 2], axis: null},\n    marks: [\n      // Plot.line([...vertices, vertices[0]], {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.geo({\n        type: \"FeatureCollection\",\n        features: triangles.map(tri =&gt; ({\n          type: \"Feature\",\n          geometry: {\n            type: \"Polygon\",\n            coordinates: [[\n              ...tri.coordinates.map(c =&gt; {\n                const p = morphedPoints.morphedMap.get(c.join(','))\n                return [p.x, p.y]\n              }),\n              (() =&gt; {\n                const p = morphedPoints.morphedMap.get(tri.coordinates[0].join(','))\n                return [p.x, p.y]\n              })()\n            ]]\n          },\n          properties: {\n            fillColor: getFillColor(tri.vertex_colors)\n          }\n        }))\n      }, {\n        fill: d =&gt; d.properties.fillColor,\n        stroke: \"black\",\n        strokeWidth: 1\n      }),\n      Plot.dot(morphedPoints.morphedPoints, {\n        x: \"x\", y: \"y\", fill: \"color\", r: 4\n      })\n    ]\n  })\n}\nviewof M = slider({\n  min: 2, max: 15, step: 1, value: 10, width: 500, title: \"Number of subdivisions\"\n})\n\nviewof s = slider({\n  min: 0, max: 1, step: 0.01, value: 0.15, width: 500, title: \"Time\"\n})\n\nmorpher3 = createTriangleMorpher(M, equilateralTriangleVertices, defaultAssignColor)\n\n\ncolorMap3 = morpher3.buildColorMap()\nmorphedMap3 = morpher3.interpolatePoints(s, colorMap3)\ntriangles3 = morpher3.generateSubTriangles(morphedMap3.morphedMap)\n\nplot3 = plotTriangles(triangles3, morphedMap3, equilateralTriangleVertices)\nLet \\(v^R\\), \\(v^G\\), and \\(v^B\\) be the vertices of the original triangle, colored red, green, and blue, respectively.\nConsider a triangulation \\(\\Delta\\) of the triangle \\((v^R, v^G, v^B)\\). We’ll use the variable \\(\\delta\\) to refer to the smaller triangles within this triangulation \\(\\Delta\\). Assume each \\(\\delta\\) is oriented counterclockwise, consistent with the orientation of \\((v^R, v^G, v^B)\\). This orientation will be important when we define signed areas.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html#time",
    "href": "9992-sperners-lemma-geometric-proof.html#time",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "Time",
    "text": "Time\nWe’ll now describe how this triangulation evolves over time.\nLet \\(t\\) be a real number in \\([0, 1]\\). Let \\(v\\) be a vertex in the subdivision, and let \\(c(v)\\) denote the color of \\(v\\). Define: \\[\\begin{align*}\nv_t = (1 - t) \\cdot v + t \\cdot v^{c(v)}\n\\end{align*}\\] so that \\(v_0 = v\\) and \\(v_1 = v^{c(v)}\\). For each triangle \\(\\delta = (v^1, v^2, v^3) \\in \\Delta\\), define: \\[\\begin{align*}\n\\delta_t = (v^1_t, v^2_t, v^3_t)\n\\end{align*}\\] and let: \\[\\begin{align*}\n\\Delta_t = \\{ \\delta_t : \\delta \\in \\Delta \\}.\n\\end{align*}\\] Note that \\(\\Delta_0 = \\Delta\\). However, \\(\\Delta_t\\) is simply a collection of triangles — it is not necessarily a triangulation of any shape. In fact, the triangles may overlap, and the union of \\(\\Delta_t\\) may not form a proper region.\nOur goal is to understand how \\(\\Delta_t\\) behaves as \\(t\\) changes.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html#signed-areas",
    "href": "9992-sperners-lemma-geometric-proof.html#signed-areas",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "(Signed) Areas",
    "text": "(Signed) Areas\nA key observation: if a triangle \\(\\delta\\) is not an RGB triangle, then \\(\\delta_1\\) becomes degenerate — it has zero area. Assume, for simplicity, that the area of the original triangle \\((v^R, v^G, v^B)\\) is 1. This allows us to use area as a tool to identify RGB triangles.\n\nTheorem 1 A triangle \\(\\delta\\) is RGB if and only if \\(\\text{area}(\\delta_1) = 1\\).\n\nWe can rephrase Sperner’s Lemma in terms of area:\n\nConjecture 1 \\[\\begin{align*}\n\\text{area}(\\Delta_1) &gt; 0,\n\\end{align*}\\] where \\[\\begin{align*}\n\\text{area}(\\Delta_t) = \\sum_{\\delta \\in \\Delta} \\text{area}(\\delta_t).\n\\end{align*}\\]\n\nIn fact, we will prove the following stronger statement:\n\nConjecture 2 \\[\\begin{align*}\n|\\Delta_1| = 1,\n\\end{align*}\\] where \\[\\begin{align*}\n|\\Delta_t| = \\sum_{\\delta \\in \\Delta} |\\delta_t|,\n\\end{align*}\\] and \\(|\\delta_t|\\) denotes the signed area of the triangle \\(\\delta_t\\).\n\nOne way to define the signed area of a counterclockwise-oriented triangle \\(\\delta = (v^1, v^2, v^3)\\) is as: \\[\\begin{align*}\n|\\delta| = \\det \\begin{bmatrix} v^2 - v^1 & v^3 - v^1 \\end{bmatrix}\n\\end{align*}\\] This is the determinant of a \\(2 \\times 2\\) matrix, and therefore the signed area of \\(\\delta_t\\) is a quadratic function of \\(t\\).\n\nTheorem 2 The signed area \\(|\\Delta_t|\\) is a quadratic function of \\(t\\).",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html#sperners-condition",
    "href": "9992-sperners-lemma-geometric-proof.html#sperners-condition",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "Sperner’s Condition",
    "text": "Sperner’s Condition\nAt time \\(t = 0\\), \\(\\Delta_0\\) is a triangulation of \\((v^R, v^G, v^B)\\), so: \\[\\begin{align*}\n|\\Delta_0| = 1.\n\\end{align*}\\]\nIf the triangulation satisfies Sperner’s condition, then for small values of \\(t &gt; 0\\), \\(\\Delta_t\\) continues to form a triangulation of the original triangle. This is the only step in the proof where we use Sperner’s condition!\n\nTheorem 3 If the coloring satisfies Sperner’s condition, then there exists \\(\\varepsilon &gt; 0\\) such that \\[\\begin{align*}\n|\\Delta_t| = 1 \\quad \\text{for all } t \\in [0, \\varepsilon].\n\\end{align*}\\]\n\nBut since \\(|\\Delta_t|\\) is a quadratic function and is constant on an interval, it must be constant everywhere.\nThis gives us the full strength of Sperner’s Lemma:\n\nTheorem 4 If the coloring satisfies Sperner’s condition, then \\(|\\Delta_t|\\) is constant in \\(t\\).\nIn particular, \\[\\begin{align*}\n|\\Delta_1| = |\\Delta_0| = 1.\n\\end{align*}\\]\n\nWith one final argument, we can strengthen this conclusion:\n\nCorollary 1 If the coloring satisfies Sperner’s condition, then \\[\\begin{align*}\n|\\{ \\text{counterclockwise oriented RGB triangles} \\}|\n=\n|\\{ \\text{clockwise oriented RGB triangles} \\}| + 1.\n\\end{align*}\\]\n\nSperner’s condition is crucial in asserting that \\(|\\Delta_t|\\) is constant. If the condition is violated, \\(\\Delta_t\\) is no longer a triangulation of the original triangle — even for small \\(t &gt; 0\\) — and thus we cannot conclude that \\(|\\Delta_t|\\) remains constant. You can see this in the app below.\n\nviewof N = slider({\n  min: 2, max: 15, step: 1, value: 10, width: 500, title: \"Number of subdivisions\"\n})\n\nviewof t = slider({\n  min: 0, max: 1, step: 0.01, value: 0.15, width: 500, title: \"Time\"\n})\n\nmorpher1 = createTriangleMorpher(N, equilateralTriangleVertices, defaultAssignColor)\n\n\ncolorMap1 = morpher1.buildColorMap()\nmorphedMap1 = morpher1.interpolatePoints(t, colorMap1)\ntriangles1 = morpher1.generateSubTriangles(morphedMap1.morphedMap)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmorpher2 = createTriangleMorpher(N, equilateralTriangleVertices, simplerAssignColor)\n\ncolorMap2 = morpher2.buildColorMap()\nmorphedMap2 = morpher2.interpolatePoints(t, colorMap2)\ntriangles2 = morpher2.generateSubTriangles(morphedMap2.morphedMap)\n\nplot1 = plotTriangles(triangles1, morphedMap1, equilateralTriangleVertices)\n\nplot2 = plotTriangles(triangles2, morphedMap2, equilateralTriangleVertices)\n\nhtml`&lt;div style=\"display: flex; gap: 1rem;\"&gt;\n  &lt;div&gt;${plot1}&lt;/div&gt;\n  &lt;div&gt;${plot2}&lt;/div&gt;\n&lt;/div&gt;`",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html#questions",
    "href": "9992-sperners-lemma-geometric-proof.html#questions",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "Questions",
    "text": "Questions\nThe combinatorial proof of Sperner’s lemma does not require the full Sperner’s condition. All it needs is that the number of boundary RG edges is odd. This condition is guaranteed by Sperner’s condition but is weaker than it. Is there a way to extend the above proofs for this alternate hypothesis?",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html#references",
    "href": "9992-sperners-lemma-geometric-proof.html#references",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "References",
    "text": "References\nMcLennan, Andrew, and Rabee Tourky. “Using Volume to Prove Sperner’s Lemma.” Economic Theory 35, no. 3 (2008): 593–97. http://www.jstor.org/stable/40282878.\nhttps://mathpages.blogspot.com/2010/05/sperners-lemma.html\nKannai, Y. Using oriented volume to prove Sperner’s lemma. Econ Theory Bull 1, 11–19 (2013). https://doi.org/10.1007/s40505-013-0013-5",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9994-sperners-lemma-statement.html",
    "href": "9994-sperners-lemma-statement.html",
    "title": "Sperner’s Lemma - Statement",
    "section": "",
    "text": "import {slider} from \"@jashkenas/inputs\"\n\n// Add a slider for M = number of points to plot\nviewof N = slider({\n  min: 2,\n  max: 20,\n  step: 1,\n  value: 15,\n  width: 500,\n  title: \"Number of subdivisions\"\n});\nequilateral_triangle_vertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\nbarycentric_coords = {\n  let result = [];\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      result.push([i, j, N - i - j]);\n    }\n  }\n  return result;\n}\nclass ColoredPoint {\n  constructor(triple, equilateralTriangleVertices, N) {\n    this.barycentricTriple = triple;\n    const [A, B, C] = equilateralTriangleVertices;\n\n    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;\n    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;\n\n    this.color = this._assignColor(triple);\n  }\n\n  _assignColor(triple) {\n    const [a, b, c] = triple;\n\n    if (a === 0 && b === 0) return 'red';\n    if (b === 0 && c === 0) return 'green';\n    if (c === 0 && a === 0) return 'blue';\n\n    // pick randomly between red and blue\n    if (a === 0) return Math.random() &lt; 0.5 ? 'red' : 'blue';\n    if (b === 0) return Math.random() &lt; 0.5 ? 'red' : 'green';\n    if (c === 0) return Math.random() &lt; 0.5 ? 'blue' : 'green';\n\n    // pick randomly between red, green, and blue\n    return Math.random() &lt; 0.33 ? 'red' : (Math.random() &lt; 0.5 ? 'green' : 'blue');\n  }\n\n  getCoords() {\n    return { x: this.x, y: this.y };\n  }\n\n  getColor() {\n    return this.color;\n  }\n}\n// A cell to generate all ColoredPoint instances\n// and also create a map for efficient lookup.\n// This cell effectively replaces your `generateColoredPoints` function and the map creation.\ncoloredPointsMap = {\n  const coloredPoints = barycentric_coords.map(triple =&gt; {\n    return new ColoredPoint(triple, equilateral_triangle_vertices, N);\n  });\n\n  // Create a Map for quick lookup of colored_points by their barycentric triple\n  let coloredPointsMap = new Map();\n  for (const p of coloredPoints) {\n    coloredPointsMap.set(`${p.barycentricTriple[0]},${p.barycentricTriple[1]},${p.barycentricTriple[2]}`, p);\n  }\n\n  // Return both the array and the map\n  return { coloredPoints, coloredPointsMap };\n}\nsubTriangles = {\n  let triangles = [];\n  // upward facing triangles\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const coordinates = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const vertex_colors = new Set([\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()\n      ]);\n      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors\n    }\n  }\n  // downward facing triangles\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const coordinates = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const vertex_colors = new Set([\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()\n      ]);\n      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors\n    }\n  }\n  return triangles;\n}\ngetFillColorALL = (vertexColors) =&gt; {\n  const numColors = vertexColors.size;\n\n  if (numColors === 3) {\n    return 'white';\n  } else if (numColors === 2) {\n    return 'rgba(255, 215, 0, 0.75)'; \n  } else if (numColors === 1) {\n    const color = [...vertexColors][0];\n    if (color === 'red') return 'rgba(255, 0, 0, 0.3)';\n    if (color === 'green') return 'rgba(0, 255, 0, 0.3)';\n    if (color === 'blue') return 'rgba(0, 0, 255, 0.3)';\n  }\n};\nviewof plotALL = Plot.plot({\n  width: 800,\n  height: 800,\n  x: {\n    label: \"x\",\n    domain: [0, 1]\n  },\n  y: {\n    label: \"y\",\n    domain: [0, Math.sqrt(3) / 2]\n  },\n  marks: [\n    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {\n      x: \"x\",\n      y: \"y\",\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.dot(coloredPointsMap.coloredPoints, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.color,\n      r: 3\n    }),\n    Plot.geo(\n      {\n        type: \"FeatureCollection\",\n        features: subTriangles.map(triangle =&gt; {\n          let coords = triangle.coordinates.map(coord =&gt; coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());\n          return {\n            type: \"Feature\",\n            geometry: {\n              type: \"Polygon\",\n              coordinates: [\n                [coords[0], coords[1], coords[2], coords[0]].map(c =&gt; [c.x, c.y])\n              ]\n            },\n            properties: { // Store the vertex colors for use in the fill\n              fillColor: getFillColorALL(triangle.vertex_colors),\n              coords: coords, // Store the coordinates\n              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array\n            }\n          };\n        })\n      },\n      {\n        fill: d =&gt; d.properties.fillColor, // Use the determined color.\n        stroke: \"black\",\n        strokeWidth: 1\n      }\n    ),\n    // Add the dots to show all colored points with their assigned color\n    Plot.dot(\n      coloredPointsMap.coloredPoints,\n      {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.color,\n        r: 4 // Decrease r as N increases\n      }\n    )\n  ]\n});\nnumRGBTriangles = subTriangles.filter(triangle =&gt; triangle.vertex_colors.size === 3).length;\nhtml`&lt;b&gt;Number of RGB triangles: ${numRGBTriangles}&lt;/b&gt;`\nSperner’s lemma is one of the first “non-trivial” theorems I remember hearing about at a high school summer camp.\nIt goes like this: consider a triangulation of a triangle. (Above, we show a regular triangulation of an equilateral triangle, but the theorem applies to any triangulation of a triangle.) We color the vertices of the triangle with three colors—say, red, green, and blue—with the following conditions:\nConditions 1 and 2 are often referred to as the Sperner condition.\nIn fact, you always have an odd number of such triangles.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Statement"
    ]
  },
  {
    "objectID": "9994-sperners-lemma-statement.html#questions",
    "href": "9994-sperners-lemma-statement.html#questions",
    "title": "Sperner’s Lemma - Statement",
    "section": "Questions",
    "text": "Questions\nWhat patterns can you see? Why are there so many RGB triangles? What is the expected number of such triangles? What about the other colored triangles?\nHere’s a curious thing I discovered while drawing these colorful plots. How do you loop over all the sub-triangles in the triangulation?",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Statement"
    ]
  },
  {
    "objectID": "9998-barycentric-coordinates.html",
    "href": "9998-barycentric-coordinates.html",
    "title": "Barycentric Coordinates",
    "section": "",
    "text": "class Triangle {\n  constructor(A, B, C, canvasObj) {\n    this.A = A;\n    this.B = B;\n    this.C = C;\n    this.canvasObj = canvasObj;\n    this.ctx = canvasObj.getContext();\n    this.CanvasA = canvasObj.toCanvas(A);\n    this.CanvasB = canvasObj.toCanvas(B);\n    this.CanvasC = canvasObj.toCanvas(C);\n  }\n\n  toCanvas(p) {\n    return this.canvasObj.toCanvas(p);\n  }\n\n  fromCanvas(p) {\n    return this.canvasObj.fromCanvas(p);\n  }\n\n  draw({ fillStyle = null, strokeStyle = \"black\", vertexColor = null } = {}) {\n    const { CanvasA, CanvasB, CanvasC, ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(...CanvasA);\n    ctx.lineTo(...CanvasB);\n    ctx.lineTo(...CanvasC);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n    if (vertexColor) {\n      [this.CanvasA, this.CanvasB, this.CanvasC].forEach(([x, y]) =&gt; {\n        ctx.beginPath();\n        ctx.arc(x, y, 5, 0, 2 * Math.PI);\n        ctx.fillStyle = vertexColor;\n        ctx.fill();\n      });\n    }\n  }\n\n  drawGrid(spacing = 0.1, color = \"rgba(200,200,200,0.5)\") {\n    const { ctx } = this;\n    for (let i = 0; i &lt;= 1; i += spacing) {\n      for (let j = 0; j &lt;= 1 - i; j += spacing) {\n        const [x, y] = this.toCanvas(this.barycentricToCartesian(i, j));\n        const neighbors = [\n          [i + spacing, j],\n          [i, j + spacing],\n          [i + spacing, j - spacing]\n        ];\n        for (const [ni, nj] of neighbors) {\n          if (ni &gt;= 0 && nj &gt;= 0 && ni + nj &lt;= 1) {\n            const [x2, y2] = this.toCanvas(this.barycentricToCartesian(ni, nj));\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x2, y2);\n            ctx.strokeStyle = color;\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  }\n\n  barycentricToCartesian(i, j) {\n    const k = 1 - i - j;\n    return [\n      i * this.A[0] + j * this.B[0] + k * this.C[0],\n      i * this.A[1] + j * this.B[1] + k * this.C[1]\n    ];\n  }\n\n  cartesianToBarycentric(x, y) {\n    const [Ax, Ay] = this.A;\n    const [Bx, By] = this.B;\n    const [Cx, Cy] = this.C;\n    const v0 = [Bx - Ax, By - Ay];\n    const v1 = [Cx - Ax, Cy - Ay];\n    const v2 = [x - Ax, y - Ay];\n    const d00 = v0[0] * v0[0] + v0[1] * v0[1];\n    const d01 = v0[0] * v1[0] + v0[1] * v1[1];\n    const d11 = v1[0] * v1[0] + v1[1] * v1[1];\n    const d20 = v2[0] * v0[0] + v2[1] * v0[1];\n    const d21 = v2[0] * v1[0] + v2[1] * v1[1];\n    const denom = d00 * d11 - d01 * d01;\n    const j = (d11 * d20 - d01 * d21) / denom;\n    const k = (d00 * d21 - d01 * d20) / denom;\n    const i = 1 - j - k;\n    return [i, j];\n  }\n}\n\nclass DraggableTriangle extends Triangle {\n  constructor(A, B, C, canvasObj) {\n    super(A, B, C, canvasObj);\n    this.draggingIndex = null;\n  }\n\n  hitTest([mx, my], radius = 10) {\n    const canvasPoints = [this.CanvasA, this.CanvasB, this.CanvasC];\n    return canvasPoints.findIndex(([x, y]) =&gt; Math.hypot(mx - x, my - y) &lt; radius);\n  }\n\n  startDrag([mx, my]) {\n    this.draggingIndex = this.hitTest([mx, my]);\n    return this.draggingIndex !== -1;\n  }\n\n  dragTo([mx, my]) {\n    if (this.draggingIndex === null) return;\n    const newCoord = this.fromCanvas([mx, my]);\n    if (this.draggingIndex === 0) this.A = newCoord;\n    else if (this.draggingIndex === 1) this.B = newCoord;\n    else if (this.draggingIndex === 2) this.C = newCoord;\n\n    this.CanvasA = this.toCanvas(this.A);\n    this.CanvasB = this.toCanvas(this.B);\n    this.CanvasC = this.toCanvas(this.C);\n  }\n\n  endDrag() {\n    this.draggingIndex = null;\n  }\n}\n\nclass Canvas {\n  constructor(width, height, scale = 200, offset = [50, 250]) {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.scale = scale;\n    this.offset = offset;\n  }\n\n  getCanvas() {\n    return this.canvas;\n  }\n\n  getContext() {\n    return this.ctx;\n  }\n\n  toCanvas([x, y]) {\n    return [this.offset[0] + x * this.scale, this.offset[1] - y * this.scale];\n  }\n\n  fromCanvas([x, y]) {\n    return [(x - this.offset[0]) / this.scale, (this.offset[1] - y) / this.scale];\n  }\n\n  drawPoint([x, y], color = \"black\") {\n    const [canvasX, canvasY] = this.toCanvas([x, y]);\n    this.ctx.beginPath();\n    this.ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);\n    this.ctx.fillStyle = color;\n    this.ctx.fill();\n  }\n\n  newTriangle(A, B, C, draggable = false) {\n    return draggable\n      ? new DraggableTriangle(A, B, C, this)\n      : new Triangle(A, B, C, this);\n  }\n}\n\n// === Observable viewof canvas ===\nviewof canvas = {\n  const width = 800, height = 400;\n  const scale = 200, offset = [50, 250];\n  const canvasInstance = new Canvas(width, height, scale, offset);\n  const canvas = canvasInstance.getCanvas();\n  const ctx = canvasInstance.getContext();\n\n  const A = [0, 0], B = [1, 0], C = [0, 1];\n  const redTri = canvasInstance.newTriangle([1.5, 0], [3, 0], [2, 1], true);\n\n  let target = { i: 0.3, j: 0.3 };\n  let current = { i: 0.3, j: 0.3 };\n\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    blackTri.drawGrid();\n    blackTri.draw({ fillStyle: \"rgba(0,0,0,0.2)\", strokeStyle: \"black\" });\n\n    redTri.drawGrid();\n    redTri.draw({ strokeStyle: \"red\", vertexColor: \"red\" });\n\n    const k = 1 - current.i - current.j;\n    const [x, y] = blackTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([x, y], \"blue\");\n\n    const [gx, gy] = redTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([gx, gy], \"green\");\n\n    ctx.fillStyle = \"black\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(`i = ${current.i.toFixed(2)}, j = ${current.j.toFixed(2)}, k = ${k.toFixed(2)}`, 75, height - 100);\n    ctx.fillText(`x = ${gx.toFixed(2)}, y = ${gy.toFixed(2)}`, 420, height - 100);\n  }\n\n  function animate() {\n    const alpha = 0.2;\n    current.i += alpha * (target.i - current.i);\n    current.j += alpha * (target.j - current.j);\n    draw();\n    requestAnimationFrame(animate);\n  }\n\n  function handleMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const [x, y] = canvasInstance.fromCanvas([mx, my]);\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n    const snapTol = 0.05;\n    const vertices = [[1, 0], [0, 1], [0, 0]];\n    const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n    const minDist = Math.min(...dists);\n    if (minDist &lt; snapTol) {\n      [target.i, target.j] = vertices[dists.indexOf(minDist)];\n    } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n      target.i = bi;\n      target.j = bj;\n    }\n  }\n\n  canvas.addEventListener(\"mousedown\", e =&gt; {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    if (redTri.startDrag([mx, my])) {\n      const move = e =&gt; {\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        redTri.dragTo([mx, my]);\n        draw();\n      };\n      const up = () =&gt; {\n        redTri.endDrag();\n        window.removeEventListener(\"mousemove\", move);\n        window.removeEventListener(\"mouseup\", up);\n      };\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", up);\n    } else {\n      // Start tracking movement to update target continuously\n      const move = e =&gt; {\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        const [x, y] = canvasInstance.fromCanvas([mx, my]);\n        const blackTri = canvasInstance.newTriangle(A, B, C);\n        const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n        const snapTol = 0.05;\n        const vertices = [[1, 0], [0, 1], [0, 0]];\n        const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n        const minDist = Math.min(...dists);\n        if (minDist &lt; snapTol) {\n          [target.i, target.j] = vertices[dists.indexOf(minDist)];\n        } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n          target.i = bi;\n          target.j = bj;\n        }\n      };\n      const up = () =&gt; {\n        window.removeEventListener(\"mousemove\", move);\n        window.removeEventListener(\"mouseup\", up);\n      };\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", up);\n    }\n  });\n\n  requestAnimationFrame(animate);\n  return canvas;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBarycentric coordinates are a coordinate system for describing points inside a triangle.\nFor a triangle with vertices \\(A\\), \\(B\\), and \\(C\\), any point \\(P\\) inside the triangle can be expressed as a weighted sum of the vertices: \\[\nP = iA + jB + kC\n\\] where \\(i\\), \\(j\\), and \\(k\\) are the barycentric coordinates, satisfying \\(i + j + k = 1\\) and \\(i, j, k \\geq 0\\). The barycentric coordinates can be interpreted as the relative areas of the sub-triangles formed with the point \\(P\\) and the vertices of the triangle.\nThere are many ways to see why this representation is valid. Here’s one visual interpretation: first, consider the triangle with vertices \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\). A point \\((x, y)\\) lies inside this triangle exactly when: \\[\n0 \\le x, \\quad 0 \\le y, \\quad \\text{and} \\quad x + y \\le 1\n\\] In this case, we can write the point \\((x, y)\\) as: \\[\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n=\n(1 - x - y) \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} +\nx \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} +\ny \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n\\] So the barycentric coordinates of \\((x, y)\\) are \\((1 - x - y, x, y)\\), all of which are non-negative and sum to 1.\nNow all you need to do is map \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\) to the vertices \\(A\\), \\(B\\), and \\(C\\), respectively, via an affine transformation. The barycentric coordinates of a point \\(P\\) inside the triangle with vertices \\(A\\), \\(B\\), and \\(C\\) are given by the same formula as above, with the standard triangle’s vertices replaced by \\(A\\), \\(B\\), and \\(C\\).\nIn the app above, you can see this in action: move the blue point around the triangle and watch how the barycentric coordinates change. You can also move the vertices of the red triangle and observe how the coordinates adapt.\n\nThis post was an excuse for me to learn how to use ObservableJS. I was initially planning to use Python and Plotly, but Plotly is absurdly immature in terms of interactivity. Most of the code was generated by ChatGPT—I merely edited it to fit my needs.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Barycentric Coordinates"
    ]
  },
  {
    "objectID": "drafts/bayes.html",
    "href": "drafts/bayes.html",
    "title": "Bayes theorem",
    "section": "",
    "text": "DRAFT DOCUMENT\n\n// Updated centralized configuration for colors\nconfigColors = ({\n  leftRegion: \"red\",    // Soft orange\n  rightRegion: \"black\",\n  outline: \"black\",          // Outline color\n  positiveRegion: \"yellow\"\n})\n\n\n\n\n\n\n\nwidth = 700;\nheight = 300;\ninitialPrevalence = 0.5; // Prevalence is now between 0 and 1\ninitialSensitivity = 0.8;\ninitialSpecificity = 0.9;\nhalfWidth = width / 2 - 5;  // Half width with a small gap\npointCount = 10000;         // Increased number of points\npointRadius = 2.5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Generate the points once and store them\npoints = Array.from({ length: pointCount }, () =&gt; ({\n  x: Math.random() * width,\n  y: Math.random() * height\n}));\n\n\n\n\n\n\n\nprevalenceLinePosition = prevalence * width; // Prevalence scaled to canvas width\nsensitivityLinePosition = prevalenceLinePosition - prevalenceLinePosition * sensitivity;\nspecificityLinePosition = width - (width - prevalenceLinePosition) * specificity;\n\n// Function for creating horizontal sliders\nfunction createSlider(min, max, value, step, width, rtl = false) {\n  const directionStyle = rtl ? \"direction: rtl;\" : \"\";\n  return html`&lt;input type=\"range\" \n    min=\"${min}\" max=\"${max}\" step=\"${step}\" value=\"${value}\" \n    style=\"width:${width}px; ${directionStyle}\"&gt;`;\n}\n\n// Horizontal sliders for prevalence, sensitivity, and specificity\nviewof prevalence = createSlider(0, 1, initialPrevalence, 0.01, width); \nviewof sensitivity = createSlider(0, 1, initialSensitivity, 0.01, halfWidth, true);\nviewof specificity = createSlider(0, 1, initialSpecificity, 0.01, halfWidth, true);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction drawCanvas() {\n  const canvas = DOM.canvas(width, height);\n  const context = canvas.getContext(\"2d\");\n  \n  // Draw regions and lines\n  const drawRect = (x, w, color) =&gt; {\n    context.fillStyle = color;\n    context.fillRect(x, 0, w, height);\n  };\n  \n  // drawRect(0, sensitivityLinePosition, configColors.negativeRegion);\n  // drawRect(specificityLinePosition, width - specificityLinePosition, configColors.negativeRegion);\n  drawRect(sensitivityLinePosition, specificityLinePosition - sensitivityLinePosition, configColors.positiveRegion);\n  \n  context.strokeStyle = configColors.outline;\n  context.lineWidth = 2;\n  context.strokeRect(0, 0, width, height);\n  \n  const drawLine = (x, color, lineWidth = 2) =&gt; {\n    context.strokeStyle = color;\n    context.beginPath();\n    context.moveTo(x, 0);\n    context.lineTo(x, height);\n    context.stroke();\n  };\n  \n  // Draw points\n  for (const point of points) {\n    context.fillStyle = point.x &lt; prevalenceLinePosition ? configColors.leftRegion : configColors.rightRegion;\n    context.beginPath();\n    context.arc(point.x, point.y, pointRadius, 0, 2 * Math.PI);\n    context.fill();\n  }\n  \n  // drawLine(prevalenceLinePosition, configColors.prevalenceLine); // Use prevalenceLinePosition\n  drawLine(sensitivityLinePosition, configColors.outline, 10);\n  drawLine(specificityLinePosition, configColors.outline, 10);\n  return canvas;\n}\n\nviewof canvas = drawCanvas();\n\n// Simple table layout for sliders\nhtml`\n&lt;table style=\"border-collapse: collapse; border: none; width: ${width}px; margin-top: 10px;\"&gt;\n  &lt;tr&gt;\n    &lt;td style=\"padding: 0; width: 50%;\"&gt;${viewof sensitivity}&lt;/td&gt;\n    &lt;td style=\"padding: 0; width: 50%;\"&gt;${viewof specificity}&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n`;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Drafts",
      "Bayes theorem"
    ]
  }
]