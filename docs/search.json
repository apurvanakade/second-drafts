[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Second Drafts",
    "section": "",
    "text": "Sperner’s Lemma - Geometric Proof\n\n\n\ntriangles\n\ncoloring\n\nquestions\n\nvisualization\n\ninteractive\n\nobservablejs\n\n\n\n\n\n\n\n\n\nMay 22, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nSperner’s Lemma - Combinatorial Proof\n\n\n\ncombinatorics\n\ntriangles\n\ncoloring\n\nvisualization\n\ninteractive\n\nobservablejs\n\nquestions\n\n\n\n\n\n\n\n\n\nMay 16, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nSperner’s Lemma - Statement\n\n\n\ncombinatorics\n\ntriangles\n\ncoloring\n\nquestions\n\nvisualization\n\ninteractive\n\nobservablejs\n\n\n\n\n\n\n\n\n\nMay 14, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nNon-Profits\n\n\n\n\n\n\n\n\nMay 13, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nRandom points in a triangle\n\n\n\nrandomness\n\ntriangles\n\nbarycentric coordinates\n\n\n\n\n\n\n\n\n\nMay 12, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nHopkins is a joke\n\n\n\n\n\n\n\n\nMay 12, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nBarycentric Coordinates\n\n\n\naffine geometry\n\nobservablejs\n\ntriangles\n\ninteractive\n\nvisualization\n\n\n\n\n\n\n\n\n\nMay 11, 2025\n\n\nApurva Nakade\n\n\n\n\n\n\n\nBegin Again\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2025\n\n\nApurva Nakade\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "9992-sperners-lemma-geometric-proof.html",
    "href": "9992-sperners-lemma-geometric-proof.html",
    "title": "Sperner’s Lemma - Geometric Proof",
    "section": "",
    "text": "DRAFT DOCUMENT\n\nimport {slider} from \"@jashkenas/inputs\"\n\n\n\n\n\n\n\nviewof N = slider({\n  min: 2, max: 10, step: 1, value: 2, width: 500, title: \"Number of subdivisions\"\n})\n\n\n\n\n\n\n\nviewof t = slider({\n  min: 0, max: 1, step: 0.01, value: 0, width: 500, title: \"time\"\n})\n\n\n\n\n\n\n\nequilateralTriangleVertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\n\n\n\n\n\n\n\ngenerateBarycentricCoords = N =&gt; {\n  const coords = []\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      coords.push([i, j, N - i - j])\n    }\n  }\n  return coords\n}\n\nbarycentricCoords = generateBarycentricCoords(N)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npickRandomColor = (...options) =&gt; options[Math.floor(Math.random() * options.length)]\n\n\n\n\n\n\n\nassignColor = (a, b, c) =&gt; {\n  if (a === 0 && b === 0) return 'red'\n  if (b === 0 && c === 0) return 'green'\n  if (c === 0 && a === 0) return 'blue'\n\n  if (a === 0) return pickRandomColor('red', 'blue')\n  if (b === 0) return pickRandomColor('red', 'green')\n  if (c === 0) return pickRandomColor('blue', 'green')\n\n  return pickRandomColor('red', 'green', 'blue')\n}\n\n\n\n\n\n\n\nbuildColorMap = N =&gt; {\n  const map = new Map()\n  const baryCoords = generateBarycentricCoords(N)\n  baryCoords.forEach(([a, b, c]) =&gt; {\n    map.set(`${a},${b},${c}`, assignColor(a, b, c))\n  })\n  return map\n}\n\ncolorMap = buildColorMap(N)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsinusoidalEase = t =&gt; (1 - Math.cos(Math.PI * t)) / 2;\n\nsmoothstepEase = t =&gt; (3 * t * t - 2 * t * t * t);\n\nsmootherstepEase = t =&gt; (6 * t**5 - 15 * t**4 + 10 * t**3);\n\n// In your interpolatePoints method\ninterpolatePoints = (t, baryCoords, vertices, colorMap) =&gt; {\n  const vertexMap = {\n    red: vertices[2],\n    green: vertices[0],\n    blue: vertices[1],\n  }\n  const [A, B, C] = vertices\n\n  const s = smootherstepEase(t);\n\n  const morphedPoints = baryCoords.map(([a, b, c]) =&gt; {\n    const sum = a + b + c;\n    const x0 = (a * A.x + b * B.x + c * C.x) / sum;\n    const y0 = (a * A.y + b * B.y + c * C.y) / sum;\n\n    const color = colorMap.get(`${a},${b},${c}`);\n    const vertex = vertexMap[color];\n\n    return {\n      x: (1 - s) * x0 + s * vertex.x,\n      y: (1 - s) * y0 + s * vertex.y,\n      color,\n      barycentricTriple: [a, b, c]\n    };\n  });\n\n  const morphedMap = new Map(morphedPoints.map(p =&gt; [\n    p.barycentricTriple.join(','), p\n  ]));\n\n  return { morphedPoints, morphedMap };\n}\n\nmorphedColoredPointsMap = interpolatePoints(t, barycentricCoords, equilateralTriangleVertices, colorMap)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenerateSubTriangles = (N, morphedMap) =&gt; {\n  const triangles = []\n\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const coords1 = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ]\n      const vertex_colors1 = coords1.map(c =&gt; morphedMap.get(c.join(',')).color)\n      triangles.push({ coordinates: coords1, vertex_colors: vertex_colors1 })\n    }\n  }\n\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const coords2 = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ]\n      const vertex_colors2 = coords2.map(c =&gt; morphedMap.get(c.join(',')).color)\n      triangles.push({ coordinates: coords2, vertex_colors: vertex_colors2 })\n    }\n  }\n\n  return triangles\n}\n\n\n\n\n\n\n\nsubTriangles = generateSubTriangles(N, morphedColoredPointsMap.morphedMap)\n\n\n\n\n\n\n\nfillColorGroups = {\n  const group1 = new Set(['RGB', 'GBR', 'BRG'])\n  const group2 = new Set(['RBG', 'BGR', 'GRB'])\n  return { group1, group2 }\n}\n\n\n\n\n\n\n\ngetFillColorRGB = vertexColors =&gt; {\n  const map = { red: 'R', green: 'G', blue: 'B' }\n  const orientation = vertexColors.map(c =&gt; map[c.toLowerCase()] || '').join('').toUpperCase()\n\n  if (fillColorGroups.group1.has(orientation)) return 'rgba(255, 145, 0, 0.25)'\n  if (fillColorGroups.group2.has(orientation)) return 'rgba(0, 128, 128, 0.25)'\n  return 'none'\n}\n\n\n\n\n\n\n\ncreateFeature = (triangle, morphedMap) =&gt; {\n  const coords = triangle.coordinates.map(c =&gt; {\n    const p = morphedMap.get(c.join(',')) || { x: 0, y: 0 }\n    return { x: p.x, y: p.y }\n  })\n\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[\n        [coords[0].x, coords[0].y],\n        [coords[1].x, coords[1].y],\n        [coords[2].x, coords[2].y],\n        [coords[0].x, coords[0].y],\n      ]],\n    },\n    properties: {\n      fillColor: getFillColorRGB(triangle.vertex_colors),\n      coords,\n      vertexColors: triangle.vertex_colors,\n    },\n  }\n}\n\n\n\n\n\n\n\nviewof plotRGB = Plot.plot({\n  width: 800,\n  height: 800,\n  x: {label: \"x\", domain: [0, 1]},\n  y: {label: \"y\", domain: [0, Math.sqrt(3) / 2]},\n  marks: [\n    Plot.line([...equilateralTriangleVertices, equilateralTriangleVertices[0]], {\n      x: \"x\",\n      y: \"y\",\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.geo({\n      type: \"FeatureCollection\",\n      features: subTriangles.map(tri =&gt; createFeature(tri, morphedColoredPointsMap.morphedMap))\n    }, {\n      fill: d =&gt; d.properties.fillColor,\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.dot(morphedColoredPointsMap.morphedPoints, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.color,\n      r: 5 * (5 / N)\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Geometric Proof"
    ]
  },
  {
    "objectID": "9997-hopkins-is-a-joke.html",
    "href": "9997-hopkins-is-a-joke.html",
    "title": "Hopkins is a joke",
    "section": "",
    "text": "It’s a crisp sunny day in the middle of way. We are deep into the final exam season. Everyone is stressed, sleep-deprived, over-caffeinated, over-worked. We have an exam for our course at 2 pm.\nWe arrive at the classroom to find it has a capacity of 150, and guess how many students we have in the class? 144. On the top of that, many of the chairs are broken. Oh and these are old, old chairs, fixed to the floor, tiny, uncomfortable - perfect for a 3 hour exam.\nProfessors have been complaining for years about outdated classrooms and what does Hopkins administration decide to do - build a new student center. The cherry on top is that the library is closed for “renovations” for ages now. So not only do we not have enough classrooms but students also do not have a place to study. Academics is clearly not a priority.\nThis is just the way of life here and we have gotten accustomed to it. But today, for something extra special, it being the finals week after all, there was a “Fire Alarm Test” DURING THE EXAM. Mind you, Hopkins really cares about it’s students - all the buildings are locked to provide quiet zones for students. So a fire alarm going on every 5 mins for an hour straight during the exam is totally fine. The administration has done their duty by posting “quite please” signs in the hallways. Now please donate to Hopkins so they can build a world class jacuzzi.\nWhat. A. Joke.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Hopkins is a joke"
    ]
  },
  {
    "objectID": "9993-sperners-lemma-combinatorial-proof.html",
    "href": "9993-sperners-lemma-combinatorial-proof.html",
    "title": "Sperner’s Lemma - Combinatorial Proof",
    "section": "",
    "text": "import { slider } from \"@jashkenas/inputs\"\n\nviewof N = slider({\n  min: 2,\n  max: 25,\n  step: 1,\n  value: 15,\n  width: 500,\n  title: \"Number of subdivisions\"\n})\nequilateral_triangle_vertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\nbarycentric_coords = {\n  let result = [];\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      result.push([i, j, N - i - j]);\n    }\n  }\n  return result;\n}\ncentroid = (p1, p2, p3) =&gt; ({\n  x: (p1.x + p2.x + p3.x) / 3,\n  y: (p1.y + p2.y + p3.y) / 3\n});\nrandomChoice = (choices) =&gt; choices[Math.floor(Math.random() * choices.length)];\n\nclass ColoredPoint {\n  constructor(triple, vertices, N) {\n    this.barycentricTriple = triple;\n    const [A, B, C] = vertices;\n\n    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;\n    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;\n\n    this.color = this._assignColor(triple);\n  }\n\n  _assignColor([a, b, c]) {\n    if (a === 0 && b === 0) return 'red';\n    if (b === 0 && c === 0) return 'green';\n    if (c === 0 && a === 0) return 'blue';\n    if (a === 0) return randomChoice(['red', 'blue']);\n    if (b === 0) return randomChoice(['red', 'green']);\n    if (c === 0) return randomChoice(['green', 'blue']);\n    return randomChoice(['red', 'green', 'blue']);\n  }\n\n  getCoords() {\n    return { x: this.x, y: this.y };\n  }\n\n  getColor() {\n    return this.color;\n  }\n}\ncoloredPointsMap = {\n  const coloredPoints = barycentric_coords.map(triple =&gt;\n    new ColoredPoint(triple, equilateral_triangle_vertices, N)\n  );\n\n  const map = new Map();\n  for (const p of coloredPoints) {\n    map.set(p.barycentricTriple.join(','), p);\n  }\n\n  return { coloredPoints, coloredPointsMap: map };\n}\ngenerateTriangleData = (coordinates, cpMap) =&gt; {\n  const points = coordinates.map(coord =&gt; cpMap.get(coord.join(',')));\n  const colors = points.map(p =&gt; p.getColor());\n  const vertex_colors = new Set(colors);\n\n  let edges = [];\n  let special_points = [];\n\n  const computeMidpoint = (a, b) =&gt; {\n    const c1 = a.getCoords();\n    const c2 = b.getCoords();\n    return {\n      x: (c1.x + c2.x) / 2,\n      y: (c1.y + c2.y) / 2\n    };\n  };\n\n  const isSpecial = (a, b) =&gt; a.barycentricTriple[1] === 0 && b.barycentricTriple[1] === 0;\n\n  const RED = 'red', GREEN = 'green', BLUE = 'blue';\n\n  if (vertex_colors.has(RED) && vertex_colors.has(GREEN) && !vertex_colors.has(BLUE)) {\n    for (let k = 0; k &lt; 3; k++) {\n      const a = points[k], b = points[(k + 1) % 3];\n      if (colors[k] !== colors[(k + 1) % 3]) {\n        const midpoint = computeMidpoint(a, b);\n        edges.push(midpoint);\n        if (isSpecial(a, b)) special_points.push(midpoint);\n      }\n    }\n  }\n\n  if (vertex_colors.has(RED) && vertex_colors.has(GREEN) && vertex_colors.has(BLUE)) {\n    for (let k = 0; k &lt; 3; k++) {\n      const pairs = [\n        [k, (k + 1) % 3],\n        [k, (k + 2) % 3]\n      ];\n\n      for (const [i, j] of pairs) {\n        if (colors[i] === RED && colors[j] === GREEN) {\n          const a = points[i], b = points[j];\n          const midpoint = computeMidpoint(a, b);\n          edges.push(midpoint);\n          if (isSpecial(a, b)) special_points.push(midpoint);\n        }\n      }\n    }\n    const centroidPoint = centroid(...points.map(p =&gt; p.getCoords()));\n    edges.push(centroidPoint);\n    special_points.push(centroidPoint);\n  }\n\n  console.log(special_points);\n  return { coordinates, vertex_colors, edges, special_points };\n}\nsubTriangles = {\n  const triangles = [], trianglesRG = [], trianglesRGB = [];\n  const cpMap = coloredPointsMap.coloredPointsMap;\n\n  // Upward\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const coords = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const data = generateTriangleData(coords, cpMap);\n      triangles.push(data);\n      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {\n        data.vertex_colors.has('blue') ? trianglesRGB.push(data) : trianglesRG.push(data);\n      }\n    }\n  }\n\n  // Downward\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const coords = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const data = generateTriangleData(coords, cpMap);\n      triangles.push(data);\n      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {\n        data.vertex_colors.has('blue') ? trianglesRGB.push(data) : trianglesRG.push(data);\n      }\n    }\n  }\n\n  return { triangles, trianglesRG, trianglesRGB };\n}\nviewof plotALL = {\n  const cpMap = coloredPointsMap.coloredPointsMap;\n\n  const triangleFeatures = (triangles, fillColor) =&gt;\n    triangles.map(({ coordinates }) =&gt; {\n      const pts = coordinates.map(c =&gt; cpMap.get(c.join(',')).getCoords());\n      return {\n        type: \"Feature\",\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [[...pts, pts[0]].map(p =&gt; [p.x, p.y])]\n        },\n        properties: { fillColor }\n      };\n    });\n\n  const makeEdgeLines = triangles =&gt;\n    triangles.flatMap(tri =&gt;\n      tri.edges.map((pt, i, arr) =&gt; {\n        const next = arr[(i + 1) % arr.length];\n        return Plot.line([pt, next], {\n          x: \"x\",\n          y: \"y\",\n          stroke: \"black\",\n          strokeWidth: 5\n        });\n      })\n    );\n\n  const makeSpecialPoints = triangles =&gt;\n    triangles.flatMap(tri =&gt;\n      tri.special_points\n        .map(pt =&gt;\n          pt && pt.x !== undefined && pt.y !== undefined\n            ? Plot.dot([pt], { x: \"x\", y: \"y\", fill: \"white\", stroke: \"black\", r: 5 })\n            : null\n        )\n        .filter(Boolean)\n    );\n\n  const edgeLines = makeEdgeLines(subTriangles.trianglesRG);\n  const edgeLinesRGB = makeEdgeLines(subTriangles.trianglesRGB);\n  const special_pointsRG = makeSpecialPoints(subTriangles.trianglesRG);\n  const special_pointsRGB = makeSpecialPoints(subTriangles.trianglesRGB);\n\n  return Plot.plot({\n    width: 800,\n    height: 800,\n    x: { label: \"x\", domain: [0, 1] },\n    y: { label: \"y\", domain: [0, Math.sqrt(3) / 2] },\n    marks: [\n      Plot.geo(\n        { type: \"FeatureCollection\", features: triangleFeatures(subTriangles.triangles, \"white\") },\n        { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n      ),\n      Plot.geo(\n        { type: \"FeatureCollection\", features: triangleFeatures(subTriangles.trianglesRG, \"rgba(255, 215, 0, 0.7)\") },\n        { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n      ),\n      Plot.geo(\n        { type: \"FeatureCollection\", features: triangleFeatures(subTriangles.trianglesRGB, \"rgba(0, 0, 0, 0.25)\") },\n        { fill: d =&gt; d.properties.fillColor, stroke: \"black\", strokeWidth: 1 }\n      ),\n      ...edgeLines,\n      ...edgeLinesRGB,\n      Plot.dot(\n        coloredPointsMap.coloredPoints.map(d =&gt; ({\n          ...d,\n          title: `(${d.barycentricTriple.join(\", \")})`\n        })),\n        {\n          x: \"x\",\n          y: \"y\",\n          fill: \"color\",\n          r: 5,\n          title: \"title\"\n        }\n      ),\n      ...special_pointsRG,\n      ...special_pointsRGB\n    ]\n  });\n}\nThis picture is a combinatorial proof of Sperner’s Lemma.\nImagine each small triangle as a room with three walls. Next we do a trick that I do not know how to motivate: treat each RG edge as a door. Here’s what we observe:\n// Create an SVG and draw three triangles with vertex colors and bold RG edges\n\nsvg = {\n  const width = 600, height = 200;\n  const svg = DOM.svg(width, height);\n  svg.setAttribute(\"width\", width);\n  svg.setAttribute(\"height\", height);\n  svg.style.background = \"#fff\";\n\n  // Triangle definitions: each vertex has [x, y, color]\n  const triangles = [\n    {\n      vertices: [\n        [50, 150, \"red\"],\n        [100, 50, \"green\"],\n        [150, 150, \"blue\"]\n      ],\n      fill: \"lightgray\",\n      label: \"RGB\"\n    },\n    {\n      vertices: [\n        [250, 150, \"red\"],\n        [300, 50, \"red\"],\n        [350, 150, \"green\"]\n      ],\n      fill: \"rgba(255, 215, 0, 1)\",\n      label: \"RRG\"\n    },\n    {\n      vertices: [\n        [450, 150, \"red\"],\n        [500, 50, \"green\"],\n        [550, 150, \"green\"]\n      ],\n      fill: \"rgba(255, 215, 0, 1)\",\n      label: \"RGG\"\n    }\n  ];\n\n  for (const {vertices, fill, label} of triangles) {\n    // Draw triangle fill\n    const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n    polygon.setAttribute(\"points\", vertices.map(v =&gt; `${v[0]},${v[1]}`).join(\" \"));\n    polygon.setAttribute(\"fill\", fill);\n    polygon.setAttribute(\"stroke\", \"black\");\n    polygon.setAttribute(\"stroke-width\", \"1\");\n    svg.appendChild(polygon);\n\n    // Draw edges with RG edges bolded\n    for (let i = 0; i &lt; 3; i++) {\n      const [x1, y1, c1] = vertices[i];\n      const [x2, y2, c2] = vertices[(i + 1) % 3];\n\n      const isRG = (c1 === \"red\" && c2 === \"green\") || (c1 === \"green\" && c2 === \"red\");\n\n      const edge = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      edge.setAttribute(\"x1\", x1);\n      edge.setAttribute(\"y1\", y1);\n      edge.setAttribute(\"x2\", x2);\n      edge.setAttribute(\"y2\", y2);\n      edge.setAttribute(\"stroke\", \"black\");\n      edge.setAttribute(\"stroke-width\", isRG ? \"4\" : \"1\");\n      if (isRG) edge.setAttribute(\"stroke-dasharray\", \"8,4\"); // dotted line\n      svg.appendChild(edge);\n    }\n\n    // Draw vertices with colors\n    for (const [x, y, color] of vertices) {\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", x);\n      circle.setAttribute(\"cy\", y);\n      circle.setAttribute(\"r\", 5);\n      circle.setAttribute(\"fill\", color);\n      svg.appendChild(circle);\n    }\n\n    // Add label\n    const [lx, ly] = vertices[1]; // top vertex\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute(\"x\", lx);\n    text.setAttribute(\"y\", ly - 10);\n    text.setAttribute(\"text-anchor\", \"middle\");\n    text.setAttribute(\"font-size\", \"12\");\n    text.setAttribute(\"font-family\", \"sans-serif\");\n    text.textContent = label;\n    svg.appendChild(text);\n  }\n\n  return svg;\n}\nIn other words, we can identify RGB triangles as the rooms with an odd number of doors. Sperner’s Lemma, then, can be restated in a more visual way:\nWe’ll prove a related version of this statement.\nPicture all the possible paths that can be formed by stepping through these RG doors — the black lines in the diagram represent all of these paths.\nUsing simple logic, we can deduce the following:\nPutting this all together gives us a key result:\nFrom this, we immediately get:\nSo to conclude the proof, all that remains is to show: The number of RG boundary edges is odd. This final step uses induction. The proof itself is short, but there’s a subtle trick — it’s easy to overlook unless you write it out carefully. Give it a shot!\nviewof M = slider({\n  min: 1,\n  max: 25,\n  step: 1,\n  value: 5,\n  width: 500,\n  title: \"Number of subdivisions\"\n})\nviewof plot = {\n  const colors = Array.from({length: M + 1}, (_, i) =&gt; {\n    if (i === 0) return \"red\";\n    if (i === M) return \"green\";\n    return Math.random() &lt; 0.5 ? \"red\" : \"green\";\n  });\n  const x = d3.scaleLinear().domain([0, M]).range([20, 580]);\n  const svg = d3.create(\"svg\").attr(\"width\", 600).attr(\"height\", 100);\n  let boldCount = 0;\n\n  for (let i = 0; i &lt; M; i++) {\n    const c1 = colors[i], c2 = colors[i + 1];\n    const bold = c1 !== c2;\n    if (bold) boldCount++;\n    svg.append(\"line\")\n      .attr(\"x1\", x(i)).attr(\"x2\", x(i + 1))\n      .attr(\"y1\", 50).attr(\"y2\", 50)\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-width\", bold ? 6 : 1);\n  }\n\n  svg.selectAll(\"circle\")\n    .data(colors)\n    .join(\"circle\")\n    .attr(\"cx\", (_, i) =&gt; x(i))\n    .attr(\"cy\", 50)\n    .attr(\"r\", 5)\n    .attr(\"fill\", d =&gt; d)\n    .attr(\"stroke\", \"black\");\n\n  svg.append(\"text\")\n    .attr(\"x\", 150).attr(\"y\", 15)\n    .text(`Number of RG edges: ${boldCount}`)\n    .attr(\"font-size\", 20);\n\n  return svg.node();\n}",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Combinatorial Proof"
    ]
  },
  {
    "objectID": "9993-sperners-lemma-combinatorial-proof.html#questions",
    "href": "9993-sperners-lemma-combinatorial-proof.html#questions",
    "title": "Sperner’s Lemma - Combinatorial Proof",
    "section": "Questions",
    "text": "Questions\nThe app at the top of this page demonstrates the proof by dividing a triangle uniformly into smaller triangles. However, Sperner’s Lemma is much more general: it applies to any triangulation of a triangle, as long as the vertices are colored according to Sperner’s condition. The proof itself never relies on the triangulation being uniform — so it holds for any triangulation. That said, the app is harder to generalize for arbitrary triangulations.\n\nHow does one generate random triangulations?\n\nOne natural approach is to use Delaunay triangulations, but how random are these triangulations? Once you have such a triangulation, the next step is:\n\nHow do you efficiently loop through all the triangles?\n\nWhile this isn’t a research question, implementing a general Sperner’s Lemma checker on arbitrary triangulations would be a neat exercise, combining computational geometry with combinatorics.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Combinatorial Proof"
    ]
  },
  {
    "objectID": "9998-barycentric-coordinates.html",
    "href": "9998-barycentric-coordinates.html",
    "title": "Barycentric Coordinates",
    "section": "",
    "text": "class Triangle {\n  constructor(A, B, C, canvasObj) {\n    this.A = A;\n    this.B = B;\n    this.C = C;\n    this.canvasObj = canvasObj;\n    this.ctx = canvasObj.getContext();\n    this.CanvasA = canvasObj.toCanvas(A);\n    this.CanvasB = canvasObj.toCanvas(B);\n    this.CanvasC = canvasObj.toCanvas(C);\n  }\n\n  toCanvas(p) {\n    return this.canvasObj.toCanvas(p);\n  }\n\n  fromCanvas(p) {\n    return this.canvasObj.fromCanvas(p);\n  }\n\n  draw({ fillStyle = null, strokeStyle = \"black\", vertexColor = null } = {}) {\n    const { CanvasA, CanvasB, CanvasC, ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(...CanvasA);\n    ctx.lineTo(...CanvasB);\n    ctx.lineTo(...CanvasC);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n    if (vertexColor) {\n      [this.CanvasA, this.CanvasB, this.CanvasC].forEach(([x, y]) =&gt; {\n        ctx.beginPath();\n        ctx.arc(x, y, 5, 0, 2 * Math.PI);\n        ctx.fillStyle = vertexColor;\n        ctx.fill();\n      });\n    }\n  }\n\n  drawGrid(spacing = 0.1, color = \"rgba(200,200,200,0.5)\") {\n    const { ctx } = this;\n    for (let i = 0; i &lt;= 1; i += spacing) {\n      for (let j = 0; j &lt;= 1 - i; j += spacing) {\n        const [x, y] = this.toCanvas(this.barycentricToCartesian(i, j));\n        const neighbors = [\n          [i + spacing, j],\n          [i, j + spacing],\n          [i + spacing, j - spacing]\n        ];\n        for (const [ni, nj] of neighbors) {\n          if (ni &gt;= 0 && nj &gt;= 0 && ni + nj &lt;= 1) {\n            const [x2, y2] = this.toCanvas(this.barycentricToCartesian(ni, nj));\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x2, y2);\n            ctx.strokeStyle = color;\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  }\n\n  barycentricToCartesian(i, j) {\n    const k = 1 - i - j;\n    return [\n      i * this.A[0] + j * this.B[0] + k * this.C[0],\n      i * this.A[1] + j * this.B[1] + k * this.C[1]\n    ];\n  }\n\n  cartesianToBarycentric(x, y) {\n    const [Ax, Ay] = this.A;\n    const [Bx, By] = this.B;\n    const [Cx, Cy] = this.C;\n    const v0 = [Bx - Ax, By - Ay];\n    const v1 = [Cx - Ax, Cy - Ay];\n    const v2 = [x - Ax, y - Ay];\n    const d00 = v0[0] * v0[0] + v0[1] * v0[1];\n    const d01 = v0[0] * v1[0] + v0[1] * v1[1];\n    const d11 = v1[0] * v1[0] + v1[1] * v1[1];\n    const d20 = v2[0] * v0[0] + v2[1] * v0[1];\n    const d21 = v2[0] * v1[0] + v2[1] * v1[1];\n    const denom = d00 * d11 - d01 * d01;\n    const j = (d11 * d20 - d01 * d21) / denom;\n    const k = (d00 * d21 - d01 * d20) / denom;\n    const i = 1 - j - k;\n    return [i, j];\n  }\n}\n\nclass DraggableTriangle extends Triangle {\n  constructor(A, B, C, canvasObj) {\n    super(A, B, C, canvasObj);\n    this.draggingIndex = null;\n  }\n\n  hitTest([mx, my], radius = 10) {\n    const canvasPoints = [this.CanvasA, this.CanvasB, this.CanvasC];\n    return canvasPoints.findIndex(([x, y]) =&gt; Math.hypot(mx - x, my - y) &lt; radius);\n  }\n\n  startDrag([mx, my]) {\n    this.draggingIndex = this.hitTest([mx, my]);\n    return this.draggingIndex !== -1;\n  }\n\n  dragTo([mx, my]) {\n    if (this.draggingIndex === null) return;\n    const newCoord = this.fromCanvas([mx, my]);\n    if (this.draggingIndex === 0) this.A = newCoord;\n    else if (this.draggingIndex === 1) this.B = newCoord;\n    else if (this.draggingIndex === 2) this.C = newCoord;\n\n    this.CanvasA = this.toCanvas(this.A);\n    this.CanvasB = this.toCanvas(this.B);\n    this.CanvasC = this.toCanvas(this.C);\n  }\n\n  endDrag() {\n    this.draggingIndex = null;\n  }\n}\n\nclass Canvas {\n  constructor(width, height, scale = 200, offset = [50, 250]) {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.scale = scale;\n    this.offset = offset;\n  }\n\n  getCanvas() {\n    return this.canvas;\n  }\n\n  getContext() {\n    return this.ctx;\n  }\n\n  toCanvas([x, y]) {\n    return [this.offset[0] + x * this.scale, this.offset[1] - y * this.scale];\n  }\n\n  fromCanvas([x, y]) {\n    return [(x - this.offset[0]) / this.scale, (this.offset[1] - y) / this.scale];\n  }\n\n  drawPoint([x, y], color = \"black\") {\n    const [canvasX, canvasY] = this.toCanvas([x, y]);\n    this.ctx.beginPath();\n    this.ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);\n    this.ctx.fillStyle = color;\n    this.ctx.fill();\n  }\n\n  newTriangle(A, B, C, draggable = false) {\n    return draggable\n      ? new DraggableTriangle(A, B, C, this)\n      : new Triangle(A, B, C, this);\n  }\n}\n\n// === Observable viewof canvas ===\nviewof canvas = {\n  const width = 800, height = 400;\n  const scale = 200, offset = [50, 250];\n  const canvasInstance = new Canvas(width, height, scale, offset);\n  const canvas = canvasInstance.getCanvas();\n  const ctx = canvasInstance.getContext();\n\n  const A = [0, 0], B = [1, 0], C = [0, 1];\n  const redTri = canvasInstance.newTriangle([1.5, 0], [3, 0], [2, 1], true);\n\n  let target = { i: 0.3, j: 0.3 };\n  let current = { i: 0.3, j: 0.3 };\n\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    blackTri.drawGrid();\n    blackTri.draw({ fillStyle: \"rgba(0,0,0,0.2)\", strokeStyle: \"black\" });\n\n    redTri.drawGrid();\n    redTri.draw({ strokeStyle: \"red\", vertexColor: \"red\" });\n\n    const k = 1 - current.i - current.j;\n    const [x, y] = blackTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([x, y], \"blue\");\n\n    const [gx, gy] = redTri.barycentricToCartesian(current.i, current.j);\n    canvasInstance.drawPoint([gx, gy], \"green\");\n\n    ctx.fillStyle = \"black\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(`i = ${current.i.toFixed(2)}, j = ${current.j.toFixed(2)}, k = ${k.toFixed(2)}`, 75, height - 100);\n    ctx.fillText(`x = ${gx.toFixed(2)}, y = ${gy.toFixed(2)}`, 420, height - 100);\n  }\n\n  function animate() {\n    const alpha = 0.2;\n    current.i += alpha * (target.i - current.i);\n    current.j += alpha * (target.j - current.j);\n    draw();\n    requestAnimationFrame(animate);\n  }\n\n  function handleMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const [x, y] = canvasInstance.fromCanvas([mx, my]);\n    const blackTri = canvasInstance.newTriangle(A, B, C);\n    const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n    const snapTol = 0.05;\n    const vertices = [[1, 0], [0, 1], [0, 0]];\n    const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n    const minDist = Math.min(...dists);\n    if (minDist &lt; snapTol) {\n      [target.i, target.j] = vertices[dists.indexOf(minDist)];\n    } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n      target.i = bi;\n      target.j = bj;\n    }\n  }\n\n  canvas.addEventListener(\"mousedown\", e =&gt; {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    if (redTri.startDrag([mx, my])) {\n      const move = e =&gt; {\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        redTri.dragTo([mx, my]);\n        draw();\n      };\n      const up = () =&gt; {\n        redTri.endDrag();\n        window.removeEventListener(\"mousemove\", move);\n        window.removeEventListener(\"mouseup\", up);\n      };\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", up);\n    } else {\n      // Start tracking movement to update target continuously\n      const move = e =&gt; {\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        const [x, y] = canvasInstance.fromCanvas([mx, my]);\n        const blackTri = canvasInstance.newTriangle(A, B, C);\n        const [bi, bj] = blackTri.cartesianToBarycentric(x, y);\n        const snapTol = 0.05;\n        const vertices = [[1, 0], [0, 1], [0, 0]];\n        const dists = vertices.map(([vi, vj]) =&gt; Math.hypot(bi - vi, bj - vj));\n        const minDist = Math.min(...dists);\n        if (minDist &lt; snapTol) {\n          [target.i, target.j] = vertices[dists.indexOf(minDist)];\n        } else if (bi &gt;= 0 && bj &gt;= 0 && bi + bj &lt;= 1) {\n          target.i = bi;\n          target.j = bj;\n        }\n      };\n      const up = () =&gt; {\n        window.removeEventListener(\"mousemove\", move);\n        window.removeEventListener(\"mouseup\", up);\n      };\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", up);\n    }\n  });\n\n  requestAnimationFrame(animate);\n  return canvas;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBarycentric coordinates are a coordinate system for describing points inside a triangle.\nFor a triangle with vertices \\(A\\), \\(B\\), and \\(C\\), any point \\(P\\) inside the triangle can be expressed as a weighted sum of the vertices: \\[\nP = iA + jB + kC\n\\] where \\(i\\), \\(j\\), and \\(k\\) are the barycentric coordinates, satisfying \\(i + j + k = 1\\) and \\(i, j, k \\geq 0\\). The barycentric coordinates can be interpreted as the relative areas of the sub-triangles formed with the point \\(P\\) and the vertices of the triangle.\nThere are many ways to see why this representation is valid. Here’s one visual interpretation: first, consider the triangle with vertices \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\). A point \\((x, y)\\) lies inside this triangle exactly when: \\[\n0 \\le x, \\quad 0 \\le y, \\quad \\text{and} \\quad x + y \\le 1\n\\] In this case, we can write the point \\((x, y)\\) as: \\[\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n=\n(1 - x - y) \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} +\nx \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} +\ny \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n\\] So the barycentric coordinates of \\((x, y)\\) are \\((1 - x - y, x, y)\\), all of which are non-negative and sum to 1.\nNow all you need to do is map \\((0, 0)\\), \\((1, 0)\\), and \\((0, 1)\\) to the vertices \\(A\\), \\(B\\), and \\(C\\), respectively, via an affine transformation. The barycentric coordinates of a point \\(P\\) inside the triangle with vertices \\(A\\), \\(B\\), and \\(C\\) are given by the same formula as above, with the standard triangle’s vertices replaced by \\(A\\), \\(B\\), and \\(C\\).\nIn the app above, you can see this in action: move the blue point around the triangle and watch how the barycentric coordinates change. You can also move the vertices of the red triangle and observe how the coordinates adapt.\n\nThis post was an excuse for me to learn how to use ObservableJS. I was initially planning to use Python and Plotly, but Plotly is absurdly immature in terms of interactivity. Most of the code was generated by ChatGPT—I merely edited it to fit my needs.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Barycentric Coordinates"
    ]
  },
  {
    "objectID": "9996-random-points-in-a-triangle.html",
    "href": "9996-random-points-in-a-triangle.html",
    "title": "Random points in a triangle",
    "section": "",
    "text": "import {Plot} from \"@observablehq/plot\"\nimport {slider} from \"@jashkenas/inputs\"\n\nN = 1000\n\nunit_triangle = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0, y: 1},\n  {x: 0, y: 0}\n]\n\nequilateral_triangle = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0}\n]\n\n// Generate N random points in the unit square\n// and label them as \"Inside\" or \"Reflected points\"\nrandom_points = Array.from({length: N}, () =&gt; {\n  let x = Math.random();\n  let y = Math.random();\n  if (x + y &lt;= 1) {\n    return {x, y, label: \"Inside\"};\n  } else {\n    return {x, y, label: \"Reflected points\"};\n  }\n});\n\n\n// Reflect the points across the midpoint of the hypotenuse\nunit_triangle_points = random_points.map(d =&gt; {\n  if (d.label === \"Reflected points\") {\n    return {x: 1 - d.x, y: 1 - d.y, label: d.label};\n  } else {\n    return d;\n  }\n});\n\n// Transform the points to the equilateral triangle using barycentric coordinates\ntransformed_points = unit_triangle_points.map(d =&gt; {\n  const A = equilateral_triangle[0];\n  const B = equilateral_triangle[1];\n  const C = equilateral_triangle[2];\n  return {\n    x: d.x * A.x + d.y * B.x + (1 - d.x - d.y) * C.x,\n    y: d.x * A.y + d.y * B.y + (1 - d.x - d.y) * C.y,\n    label: d.label\n  };\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Add a slider for M = number of points to plot\nviewof M = slider({\n  min: 0,\n  max: N,\n  step: 1,\n  value: 100,\n  width: 500\n});\n\n\n\n\n\n\n\nviewof sideBySidePlots = {\n  // Create the title element\n  const title = document.createElement(\"h4\");\n  title.textContent = \"Generate points in a unit square, and reflect the points that lie above the hypotenuse\";\n  title.style.marginBottom = \"1em\";\n\n  // Create the first plot\n  const plot1 = Plot.plot({\n    width: 400,\n    height: 400,\n    x: {domain: [0, 1]},\n    y: {domain: [0, 1]},\n    marks: [\n      Plot.dot(random_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(unit_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0, y: 1}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Create the second plot\n  const plot2 = Plot.plot({\n    width: 400,\n    height: 400,\n    x: {domain: [0, 1]},\n    y: {domain: [0, 1]},\n    marks: [\n      Plot.dot(unit_triangle_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(unit_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0, y: 1}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Layout container\n  const container = document.createElement(\"div\");\n  container.style.display = \"flex\";\n  container.style.gap = \"20px\";\n\n  // Outer wrapper with title and plots\n  const wrapper = document.createElement(\"div\");\n  wrapper.append(title, container);\n  container.append(plot1, plot2);\n\n  return wrapper;\n}\n\n\n\n\n\n\n\n// Plot the first M points and center align it to the screen\nviewof centeredPlot = {\n  // Create the title element\n  const title = document.createElement(\"h4\");\n  title.textContent = \"Barycentric transformation to map unit triangle into equilateral triangle\";\n  title.style.marginBottom = \"1em\";\n\n  // Create the plot\n  const plot = Plot.plot({\n    width: 500,\n    height: 500,\n    x: {domain: [0, 1]},\n    y: {domain: [0, Math.sqrt(3) / 2]},\n    marks: [\n      Plot.dot(transformed_points.slice(0, M), {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.label === \"Inside\" ? \"red\" : \"blue\",\n        r: 3\n      }),\n      Plot.lineY(equilateral_triangle, {x: \"x\", y: \"y\", stroke: \"black\", strokeWidth: 1}),\n      Plot.lineY([{x: 0, y: 0}, {x: 1, y: 0}], {stroke: \"black\", strokeDasharray: \"4,4\"}),\n      Plot.lineY([{x: 0, y: 0}, {x: 0.5, y: Math.sqrt(3) / 2}], {stroke: \"black\", strokeDasharray: \"4,4\"})\n    ]\n  });\n\n  // Center the plot inside a container\n  const container = document.createElement(\"div\");\n  container.style.display = \"flex\";\n  container.style.flexDirection = \"column\";\n  container.style.alignItems = \"center\";\n  container.append(title, plot);\n\n  return container;\n}\n\n\n\n\n\n\nRandomness is a surprisingly hard thing to simulate. Any program, by definition, has a predictable output. The best you can hope for is to predictably generate points that look random (pseudo-random) and fool some statistical tests. All random generation relies on two things:\n\nA pseudo-random number generator that outputs a stream of numbers that “looks random”\nA mathematical function that converts uniform random variable(s) into random variables with other distributions\n\nMathematicians are mostly interested in engineering Step 2. Step 1 is important but is usually delegated to computer engineers.\nWith that preamble, here’s the question: Generate points randomly inside a triangle. I need this in order to play around with Sperner’s lemma examples.\nThe first step is to generate random points in the “standard triangle” with vertices \\([0, 0], [1, 0], [0, 1]\\). A very simple trick for this is to generate points in the unit square and “reflect the points” across the midpoint of the hypotenuse, \\([0.5, 0.5]\\).\nNext, we use the barycentric transformation to transform the standard triangle into the desired triangle—in the example above, the equilateral triangle with vertices \\([0, 0], [1, 0], [0.5, \\sqrt{3}/2]\\).\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Random points in a triangle"
    ]
  },
  {
    "objectID": "9999-begin-again.html",
    "href": "9999-begin-again.html",
    "title": "Begin Again",
    "section": "",
    "text": "I opened this page with a clear idea of what I wanted to write. I’ve now spent the last half hour updating quarto, setting up a new git repository, fixing a git merge issue, figuring out how to render drafts… this was a mistake. When I have something to write, I need to get the words out as soon as possible without worrying about their final destination.\n\nOne of the protagonist in 1Q84, Tengo, is a writer. He teaches math at cram schools to make a living but his real passion is writing. At some point in his life he has to decide between writing and math, and he decides to write. Tengo is my alter-ego from a different dimension. He chose writing just as I chose math. Thankfully math pays so I do not have to teach writing for a living.\nI’ve always loved writing. I have had several blogs representing different phrases of my life, each reflective of what I was going through at the time but haven’t maintained one of late for various inane excuses.\nI recently started reading The Artist’s Way and it inspired me to write again. I sometimes get stuck in arguments, trying to find reasons to justify doing or not doing something, analysis paralysis. Very simply though, I just enjoy putting thoughts into words, which is justification enough to write. I heard Neil Gaiman talk about how he likes to write with a fountain pen. Writing here is the equivalent of writing with a fountain pen for me - just watching words magically appear on the screen out of nowhere.\nThis journal is going to be a collection of my second drafts - nothing polished or well-thought but not stream-of-conscious either. As Sam Harris says, it’s never late to begin again.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Begin Again"
    ]
  },
  {
    "objectID": "9994-sperners-lemma-statement.html",
    "href": "9994-sperners-lemma-statement.html",
    "title": "Sperner’s Lemma - Statement",
    "section": "",
    "text": "import {slider} from \"@jashkenas/inputs\"\n\n// Add a slider for M = number of points to plot\nviewof N = slider({\n  min: 2,\n  max: 20,\n  step: 1,\n  value: 5,\n  width: 500,\n  title: \"Number of subdivisions\"\n});\nequilateral_triangle_vertices = [\n  {x: 1, y: 0},\n  {x: 0.5, y: Math.sqrt(3) / 2},\n  {x: 0, y: 0},\n]\nbarycentric_coords = {\n  let result = [];\n  for (let i = 0; i &lt;= N; i++) {\n    for (let j = 0; j &lt;= N - i; j++) {\n      result.push([i, j, N - i - j]);\n    }\n  }\n  return result;\n}\nclass ColoredPoint {\n  constructor(triple, equilateralTriangleVertices, N) {\n    this.barycentricTriple = triple;\n    const [A, B, C] = equilateralTriangleVertices;\n\n    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;\n    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;\n\n    this.color = this._assignColor(triple);\n  }\n\n  _assignColor(triple) {\n    const [a, b, c] = triple;\n\n    if (a === 0 && b === 0) return 'red';\n    if (b === 0 && c === 0) return 'green';\n    if (c === 0 && a === 0) return 'blue';\n\n    // pick randomly between red and blue\n    if (a === 0) return Math.random() &lt; 0.5 ? 'red' : 'blue';\n    if (b === 0) return Math.random() &lt; 0.5 ? 'red' : 'green';\n    if (c === 0) return Math.random() &lt; 0.5 ? 'blue' : 'green';\n\n    // pick randomly between red, green, and blue\n    return Math.random() &lt; 0.33 ? 'red' : (Math.random() &lt; 0.5 ? 'green' : 'blue');\n  }\n\n  getCoords() {\n    return { x: this.x, y: this.y };\n  }\n\n  getColor() {\n    return this.color;\n  }\n}\n// A cell to generate all ColoredPoint instances\n// and also create a map for efficient lookup.\n// This cell effectively replaces your `generateColoredPoints` function and the map creation.\ncoloredPointsMap = {\n  const coloredPoints = barycentric_coords.map(triple =&gt; {\n    return new ColoredPoint(triple, equilateral_triangle_vertices, N);\n  });\n\n  // Create a Map for quick lookup of colored_points by their barycentric triple\n  let coloredPointsMap = new Map();\n  for (const p of coloredPoints) {\n    coloredPointsMap.set(`${p.barycentricTriple[0]},${p.barycentricTriple[1]},${p.barycentricTriple[2]}`, p);\n  }\n\n  // Return both the array and the map\n  return { coloredPoints, coloredPointsMap };\n}\nsubTriangles = {\n  let triangles = [];\n  // upward facing triangles\n  for (let i = 0; i &lt; N; i++) {\n    for (let j = 0; j &lt; N - i; j++) {\n      const coordinates = [\n        [i, j, N - i - j],\n        [i + 1, j, N - i - j - 1],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const vertex_colors = new Set([\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()\n      ]);\n      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors\n    }\n  }\n  // downward facing triangles\n  for (let i = 0; i &lt; N - 1; i++) {\n    for (let j = 0; j &lt; N - i - 1; j++) {\n      const coordinates = [\n        [i + 1, j, N - i - j - 1],\n        [i + 1, j + 1, N - i - j - 2],\n        [i, j + 1, N - i - j - 1]\n      ];\n      const vertex_colors = new Set([\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),\n        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()\n      ]);\n      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors\n    }\n  }\n  return triangles;\n}\n// Determine the fill color based on the vertex colors.\ngetFillColorALL = (vertexColors) =&gt; {\n  if (vertexColors.has('red') && vertexColors.has('green') && vertexColors.has('blue')) {\n    return 'rgba(0, 0, 0, 0.3)'; // black (RGB mix)\n  } else if (vertexColors.has('red') && vertexColors.has('green')) {\n    return 'rgba(255, 255, 0, 0.3)'; // yellow (R + G)\n  } else if (vertexColors.has('red') && vertexColors.has('blue')) {\n    return 'rgba(255, 0, 255, 0.3)'; // magenta (R + B)\n  } else if (vertexColors.has('green') && vertexColors.has('blue')) {\n    return 'rgba(0, 255, 255, 0.3)'; // cyan (G + B)\n  } else if (vertexColors.has('red')) {\n    return 'rgba(255, 0, 0, 0.3)'; // red\n  } else if (vertexColors.has('green')) {\n    return 'rgba(0, 255, 0, 0.3)'; // green\n  } else if (vertexColors.has('blue')) {\n    return 'rgba(0, 0, 255, 0.3)'; // blue\n  }\n  return 'rgba(0, 0, 0, 0)'; // fully transparent fallback\n};\nviewof plotALL = Plot.plot({\n  width: 800,\n  height: 800,\n  x: {\n    label: \"x\",\n    domain: [0, 1]\n  },\n  y: {\n    label: \"y\",\n    domain: [0, Math.sqrt(3) / 2]\n  },\n  marks: [\n    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {\n      x: \"x\",\n      y: \"y\",\n      stroke: \"black\",\n      strokeWidth: 1\n    }),\n    Plot.dot(coloredPointsMap.coloredPoints, {\n      x: \"x\",\n      y: \"y\",\n      fill: d =&gt; d.color,\n      r: 3\n    }),\n    Plot.geo(\n      {\n        type: \"FeatureCollection\",\n        features: subTriangles.map(triangle =&gt; {\n          let coords = triangle.coordinates.map(coord =&gt; coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());\n          return {\n            type: \"Feature\",\n            geometry: {\n              type: \"Polygon\",\n              coordinates: [\n                [coords[0], coords[1], coords[2], coords[0]].map(c =&gt; [c.x, c.y])\n              ]\n            },\n            properties: { // Store the vertex colors for use in the fill\n              fillColor: getFillColorALL(triangle.vertex_colors),\n              coords: coords, // Store the coordinates\n              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array\n            }\n          };\n        })\n      },\n      {\n        fill: d =&gt; d.properties.fillColor, // Use the determined color.\n        stroke: \"black\",\n        strokeWidth: 1\n      }\n    ),\n    // Add the dots to show all colored points with their assigned color\n    Plot.dot(\n      coloredPointsMap.coloredPoints,\n      {\n        x: \"x\",\n        y: \"y\",\n        fill: d =&gt; d.color,\n        r: 5 * (5 / N) // Decrease r as N increases\n      }\n    )\n  ]\n});\nnumRGBTriangles = subTriangles.filter(triangle =&gt; triangle.vertex_colors.size === 3).length;\nhtml`&lt;b&gt;Number of RGB triangles: ${numRGBTriangles}&lt;/b&gt;`\nSperner’s lemma is one of the first “non-trivial” theorems I remember hearing about at a high school summer camp.\nIt goes like this: consider a triangulation of a triangle. (Above, we show a regular triangulation of an equilateral triangle, but the theorem applies to any triangulation of a triangle.) We color the vertices of the triangle with three colors—say, red, green, and blue—with the following conditions:\nConditions 1 and 2 are often referred to as the Sperner condition.\nIn fact, you always have an odd number of such triangles.",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Statement"
    ]
  },
  {
    "objectID": "9994-sperners-lemma-statement.html#questions",
    "href": "9994-sperners-lemma-statement.html#questions",
    "title": "Sperner’s Lemma - Statement",
    "section": "Questions",
    "text": "Questions\nWhat patterns can you see? Why are there so many RGB triangles? What is the expected number of such triangles? What about the other colored triangles?\nHere’s a curious thing I discovered while drawing these colorful plots. How do you loop over all the sub-triangles in the triangulation?",
    "crumbs": [
      "Home",
      "Sperner's Lemma - Statement"
    ]
  },
  {
    "objectID": "9995-non-profits.html",
    "href": "9995-non-profits.html",
    "title": "Non-Profits",
    "section": "",
    "text": "My apartment complex in DC is having some landlord issues. Our landlord is a shady, dishonest guy whose main skill is not getting sued. He will do the absolute least he can to avoid being held liable. This post is not about him, though. This post is about some awesome people in DC.\nWe are having some legal issues with the landlord, and one of our fellow tenants reached out to some DC non-profits called Legal Aid DC and Housing Counseling Services. Some of their hardworking folks came to our apartment and talked to us about DC tenant laws, patiently answering all of our dumb questions. They spent their valuable time with us after a busy day and gave us the gift of time and knowledge – all of this at no cost! By the end of our meeting, we all breathed a sigh of relief – a big burden had been taken off our shoulders.\nI was touched by their generosity, and it made me greatly appreciate the value of non-profits. It made me appreciate how much impact small acts of kindness can have. I hope to be able to support these organizations somehow, but more importantly, to spread their message and spirit.\n\n\n\n Back to top",
    "crumbs": [
      "Home",
      "Non-Profits"
    ]
  }
]