---
title: Sperner's Lemma
author: Apurva Nakade
date: 2025-05-14 17:20:25
categories: [combinatorics, triangles, coloring]
# draft: true
---

**DRAFT DOCUMENT**

```{ojs}
equilateral_triangle_vertices = [
  {x: 0, y: 0},
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2}
]
```

```{ojs}
import {slider} from "@jashkenas/inputs"

// Add a slider for M = number of points to plot
viewof N = slider({
  min: 2,
  max: 100,
  step: 1,
  value: 10,
  width: 500,
  title: "Number of subdivisions"
});
```

```{ojs}
barycentric_coords = {
  let result = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      result.push([i, j, N - i - j]);
    }
  }
  return result;
}
```


```{ojs}
class ColoredPoint {
  constructor(triple, equilateralTriangleVertices, N) {
    this.barycentricTriple = triple;
    const [A, B, C] = equilateralTriangleVertices;

    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;
    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;

    this.color = this._assignColor(triple);
  }

  _assignColor(triple) {
    const [a, b, c] = triple;

    if (a === 0 && b === 0) return 'red';
    if (b === 0 && c === 0) return 'green';
    if (c === 0 && a === 0) return 'blue';

    // pick randomly between red and blue
    if (a === 0) return Math.random() < 0.5 ? 'red' : 'blue';
    if (b === 0) return Math.random() < 0.5 ? 'red' : 'green';
    if (c === 0) return Math.random() < 0.5 ? 'blue' : 'green';

    // pick randomly between red, green, and blue
    return Math.random() < 0.33 ? 'red' : (Math.random() < 0.5 ? 'green' : 'blue');
  }

  getCoords() {
    return { x: this.x, y: this.y };
  }

  getColor() {
    return this.color;
  }
}
```

```{ojs}
// A cell to generate all ColoredPoint instances
// and also create a map for efficient lookup.
// This cell effectively replaces your `generateColoredPoints` function and the map creation.
coloredPointsMap = {
  const coloredPoints = barycentric_coords.map(triple => {
    return new ColoredPoint(triple, equilateral_triangle_vertices, N);
  });

  // Create a Map for quick lookup of colored_points by their barycentric triple
  let coloredPointsMap = new Map();
  for (const p of coloredPoints) {
    coloredPointsMap.set(`${p.barycentricTriple[0]},${p.barycentricTriple[1]},${p.barycentricTriple[2]}`, p);
  }

  // Return both the array and the map
  return { coloredPoints, coloredPointsMap };
}
```

```{ojs}
// plot colored_points in the plane 

viewof plot = Plot.plot({
  width: 600,
  height: 600,
  x: {
    label: "x",
    domain: [0, 1]
  },
  y: {
    label: "y",
    domain: [0, Math.sqrt(3) / 2]
  },
  marks: [
    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {x: "x", y: "y", stroke: "black", strokeWidth: 1}),
    Plot.dot(coloredPointsMap.coloredPoints, {x: "x", y: "y", fill: d => d.color, r: 3})
  ]
})
```

```{ojs}
subTriangles = {
  let triangles = [];
  // upward facing triangles
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coordinates = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ];
      const vertex_colors = new Set([
        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()
      ]);
      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors
    }
  }
  // downward facing triangles
  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coordinates = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ];
      const vertex_colors = new Set([
        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()
      ]);
      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors
    }
  }
  return triangles;
}
```

```{ojs}
// Determine the fill color based on the vertex colors.
getFillColor = (vertexColors) => {
  if (vertexColors.has('red') && vertexColors.has('green') && vertexColors.has('blue')) {
    return 'none'; // Or any color you prefer for RGB triangles
  } else if (vertexColors.has('red') && vertexColors.has('green')) {
    return 'yellow';
  } else if (vertexColors.has('red') && vertexColors.has('blue')) {
    return 'none';
  } else if (vertexColors.has('green') && vertexColors.has('blue')) {
    return 'none';
  } else if (vertexColors.has('red')) {
    return 'none';
  } else if (vertexColors.has('green')) {
    return 'none';
  } else if (vertexColors.has('blue')) {
    return 'none';
  }
  return 'none'; // Default color
};
```

```{ojs}
viewof plot2 = Plot.plot({
  width: 600,
  height: 600,
  x: {
    label: "x",
    domain: [0, 1]
  },
  y: {
    label: "y",
    domain: [0, Math.sqrt(3) / 2]
  },
  marks: [
    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {
      x: "x",
      y: "y",
      stroke: "black",
      strokeWidth: 1
    }),
    Plot.dot(coloredPointsMap.coloredPoints, {
      x: "x",
      y: "y",
      fill: d => d.color,
      r: 3
    }),
    Plot.geo(
      {
        type: "FeatureCollection",
        features: subTriangles.map(triangle => {
          let coords = triangle.coordinates.map(coord => coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());
          return {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [
                [coords[0], coords[1], coords[2], coords[0]].map(c => [c.x, c.y])
              ]
            },
            properties: { // Store the vertex colors for use in the fill
              fillColor: getFillColor(triangle.vertex_colors),
            }
          };
        })
      },
      {
        fill: d => d.properties.fillColor, // Use the determined color.
        stroke: "purple",
        strokeWidth: 2
      }
    )
  ]
});

```