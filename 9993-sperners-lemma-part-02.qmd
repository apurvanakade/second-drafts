---
title: Sperner's Lemma - Part 02
author: Apurva Nakade
date: 2025-05-16 09:44:57
categories: [combinatorics, triangles, coloring]
---

**DRAFT DOCUMENT**

```{ojs}
import {slider} from "@jashkenas/inputs"

// Add a slider for M = number of points to plot
viewof N = slider({
  min: 2,
  max: 20,
  step: 1,
  value: 5,
  width: 500,
  title: "Number of subdivisions"
});
```

```{ojs}
equilateral_triangle_vertices = [
  {x: 0, y: 0},
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2}
]
```

```{ojs}
barycentric_coords = {
  let result = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      result.push([i, j, N - i - j]);
    }
  }
  return result;
}
```


```{ojs}
// Utility function to calculate the centroid (median point) of a triangle
centroid = (p1, p2, p3) => {
  const cx = (p1.x + p2.x + p3.x) / 3;
  const cy = (p1.y + p2.y + p3.y) / 3;
  return { x: cx, y: cy };
};
```

```{ojs}
class ColoredPoint {
  constructor(triple, equilateralTriangleVertices, N) {
    this.barycentricTriple = triple;
    const [A, B, C] = equilateralTriangleVertices;

    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;
    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;

    this.color = this._assignColor(triple);
  }

  _assignColor(triple) {
    const [a, b, c] = triple;

    if (a === 0 && b === 0) return 'red';
    if (b === 0 && c === 0) return 'green';
    if (c === 0 && a === 0) return 'blue';

    // pick randomly between red and blue
    if (a === 0) return Math.random() < 0.5 ? 'red' : 'blue';
    if (b === 0) return Math.random() < 0.5 ? 'red' : 'green';
    if (c === 0) return Math.random() < 0.5 ? 'blue' : 'green';

    // pick randomly between red, green, and blue
    return Math.random() < 0.33 ? 'red' : (Math.random() < 0.5 ? 'green' : 'blue');
  }

  getCoords() {
    return { x: this.x, y: this.y };
  }

  getColor() {
    return this.color;
  }
}
```

```{ojs}
// A cell to generate all ColoredPoint instances
// and also create a map for efficient lookup.
// This cell effectively replaces your `generateColoredPoints` function and the map creation.
coloredPointsMap = {
  const coloredPoints = barycentric_coords.map(triple => {
    return new ColoredPoint(triple, equilateral_triangle_vertices, N);
  });

  // Create a Map for quick lookup of colored_points by their barycentric triple
  let coloredPointsMap = new Map();
  for (const p of coloredPoints) {
    coloredPointsMap.set(`${p.barycentricTriple[0]},${p.barycentricTriple[1]},${p.barycentricTriple[2]}`, p);
  }

  // Return both the array and the map
  return { coloredPoints, coloredPointsMap };
}
```


```{ojs}
subTriangles = {
  let triangles = [];
  let trianglesRG = [];
  let trianglesRGB = [];
  
  // upward facing triangles
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coordinates = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ];
      // first save colors in an array
      // then convert to a set to remove duplicates

      const ordered_vertex_colors = [
        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()
      ];
      const vertex_colors = new Set(ordered_vertex_colors);

      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors

      // Check for red-green triangles
      if (vertex_colors.has('red') && vertex_colors.has('green')) {
        if (vertex_colors.has('blue')) {
          trianglesRGB.push({ coordinates, vertex_colors });
        } else {
          // find midpoints of vertices with different colors
          const midpoints = [];
          for (let k = 0; k < coordinates.length; k++) {
            const p1 = coloredPointsMap.coloredPointsMap.get(`${coordinates[k][0]},${coordinates[k][1]},${coordinates[k][2]}`);
            const p2 = coloredPointsMap.coloredPointsMap.get(`${coordinates[(k + 1) % coordinates.length][0]},${coordinates[(k + 1) % coordinates.length][1]},${coordinates[(k + 1) % coordinates.length][2]}`);
            if (p1.getColor() !== p2.getColor()) {
              midpoints.push({
                x: (p1.getCoords().x + p2.getCoords().x) / 2,
                y: (p1.getCoords().y + p2.getCoords().y) / 2
              });
            }
          }
          trianglesRG.push({ coordinates, vertex_colors, midpoints }); // Added vertex_colors and midpoints
        } 
      }
    }
  }
  // downward facing triangles
  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coordinates = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ];
      const ordered_vertex_colors = [
        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()
      ];
      const vertex_colors = new Set(ordered_vertex_colors);

      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors

      // Check for red-green triangles
      if (vertex_colors.has('red') && vertex_colors.has('green')) {
        if (vertex_colors.has('blue')) {
          trianglesRGB.push({ coordinates, vertex_colors });
        } else {
          // find midpoints of vertices with different colors
          const midpoints = [];
          for (let k = 0; k < coordinates.length; k++) {
            const p1 = coloredPointsMap.coloredPointsMap.get(`${coordinates[k][0]},${coordinates[k][1]},${coordinates[k][2]}`);
            const p2 = coloredPointsMap.coloredPointsMap.get(`${coordinates[(k + 1) % coordinates.length][0]},${coordinates[(k + 1) % coordinates.length][1]},${coordinates[(k + 1) % coordinates.length][2]}`);
            if (p1.getColor() !== p2.getColor()) {
                midpoints.push({
                x: (p1.getCoords().x + p2.getCoords().x) / 2,
                y: (p1.getCoords().y + p2.getCoords().y) / 2
                });
            }
          }
          trianglesRG.push({ coordinates, vertex_colors, midpoints }); // Added vertex_colors and midpoints
        } 
      }
    }
  }
  return {
    triangles,
    trianglesRG,
    trianglesRGB
  };
}
```


```{ojs}
// Determine the fill color based on the vertex colors.
getFillColorALL = (vertexColors) => {
  if (vertexColors.has('red') && vertexColors.has('green') && vertexColors.has('blue')) {
    return 'orange'; // Or any color you prefer for RGB triangles
  } else if (vertexColors.has('red') && vertexColors.has('green')) {
    return 'yellow';
  }
  return 'none'; // Default color
};
```

```{ojs}
viewof plotALL = Plot.plot({
  width: 800,
  height: 800,
  x: {
    label: "x",
    domain: [0, 1]
  },
  y: {
    label: "y",
    domain: [0, Math.sqrt(3) / 2]
  },
  marks: [
    // Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {
    //   x: "x",
    //   y: "y",
    //   stroke: "black",
    //   strokeWidth: 1
    // }),
    Plot.dot(coloredPointsMap.coloredPoints, {
      x: "x",
      y: "y",
      fill: d => d.color,
      r: 3
    }),
    Plot.geo(
      {
        type: "FeatureCollection",
        features: subTriangles.trianglesRG.map(triangle => {
          let coords = triangle.coordinates.map(coord => coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());
          return {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [
                [coords[0], coords[1], coords[2], coords[0]].map(c => [c.x, c.y])
              ]
            },
            properties: { // Store the vertex colors for use in the fill
              fillColor: 'yellow',
              coords: coords, // Store the coordinates
              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array
            }
          };
        })
      },
      {
        fill: d => d.properties.fillColor, // Use the determined color.
        stroke: "black",
        strokeWidth: 0
      }
    ),
    // Plot the edges connecting the midpoints of the triangles with red-green coloring
    ...subTriangles.trianglesRG.flatMap(triangle => {
      return triangle.midpoints.map((coord, index) => {
      const nextCoord = triangle.midpoints[(index + 1) % triangle.midpoints.length];
      return Plot.line(
        [
        { x: coord.x, y: coord.y },
        { x: nextCoord.x, y: nextCoord.y }
        ],
        {
        x: "x",
        y: "y",
        stroke: "black",
        strokeWidth: 5
        }
      );
      });
    }),
    Plot.geo(
      {
        type: "FeatureCollection",
        features: subTriangles.trianglesRGB.map(triangle => {
          let coords = triangle.coordinates.map(coord => coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());
          return {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [
                [coords[0], coords[1], coords[2], coords[0]].map(c => [c.x, c.y])
              ]
            },
            properties: { // Store the vertex colors for use in the fill
                fillColor: 'rgba(0, 0, 0, 0.05)',
              coords: coords, // Store the coordinates
              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array
            }
          };
        })
      },
      {
        fill: d => d.properties.fillColor, // Use the determined color.
        stroke: "black",
        strokeWidth: 0
      }
    ),
    // Add the dots to show all colored points with their assigned color
    Plot.dot(
      coloredPointsMap.coloredPoints,
      {
        x: "x",
        y: "y",
        fill: d => d.color,
        r: 5 * (5 / N) // Decrease r as N increases
      }
    )
  ]
});
```



