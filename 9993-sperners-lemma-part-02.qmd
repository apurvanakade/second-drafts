---
title: Sperner's Lemma - Part 02
author: Apurva Nakade
date: 2025-05-16 09:44:57
categories: [combinatorics, triangles, coloring]
---

**DRAFT DOCUMENT**

```{ojs}
import { slider } from "@jashkenas/inputs"

viewof N = slider({
  min: 2,
  max: 25,
  step: 1,
  value: 15,
  width: 500,
  title: "Number of subdivisions"
})
```

```{ojs}
equilateral_triangle_vertices = [
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2},
  {x: 0, y: 0},
]
```

```{ojs}
barycentric_coords = {
  let result = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      result.push([i, j, N - i - j]);
    }
  }
  return result;
}
```


```{ojs}
centroid = (p1, p2, p3) => ({
  x: (p1.x + p2.x + p3.x) / 3,
  y: (p1.y + p2.y + p3.y) / 3
});
```

```{ojs}
randomChoice = (choices) => choices[Math.floor(Math.random() * choices.length)];

class ColoredPoint {
  constructor(triple, vertices, N) {
    this.barycentricTriple = triple;
    const [A, B, C] = vertices;

    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;
    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;

    this.color = this._assignColor(triple);
  }

  _assignColor([a, b, c]) {
    if (a === 0 && b === 0) return 'red';
    if (b === 0 && c === 0) return 'green';
    if (c === 0 && a === 0) return 'blue';
    if (a === 0) return randomChoice(['red', 'blue']);
    if (b === 0) return randomChoice(['red', 'green']);
    if (c === 0) return randomChoice(['green', 'blue']);
    return randomChoice(['red', 'green', 'blue']);
  }

  getCoords() {
    return { x: this.x, y: this.y };
  }

  getColor() {
    return this.color;
  }
}
```

```{ojs}
coloredPointsMap = {
  const coloredPoints = barycentric_coords.map(triple =>
    new ColoredPoint(triple, equilateral_triangle_vertices, N)
  );

  const map = new Map();
  for (const p of coloredPoints) {
    map.set(p.barycentricTriple.join(','), p);
  }

  return { coloredPoints, coloredPointsMap: map };
}
```


```{ojs}
generateTriangleData = (coordinates, cpMap) => {
  const points = coordinates.map(coord => cpMap.get(coord.join(',')));
  const colors = points.map(p => p.getColor());
  const vertex_colors = new Set(colors);

  let edges = [];
  let special_points = [];

  const computeMidpoint = (a, b) => {
    const c1 = a.getCoords();
    const c2 = b.getCoords();
    return {
      x: (c1.x + c2.x) / 2,
      y: (c1.y + c2.y) / 2
    };
  };

  const isSpecial = (a, b) => a.barycentricTriple[1] === 0 && b.barycentricTriple[1] === 0;

  const RED = 'red', GREEN = 'green', BLUE = 'blue';

  if (vertex_colors.has(RED) && vertex_colors.has(GREEN) && !vertex_colors.has(BLUE)) {
    for (let k = 0; k < 3; k++) {
      const a = points[k], b = points[(k + 1) % 3];
      if (colors[k] !== colors[(k + 1) % 3]) {
        const midpoint = computeMidpoint(a, b);
        edges.push(midpoint);
        if (isSpecial(a, b)) special_points.push(midpoint);
      }
    }
  }

  if (vertex_colors.has(RED) && vertex_colors.has(GREEN) && vertex_colors.has(BLUE)) {
    for (let k = 0; k < 3; k++) {
      const pairs = [
        [k, (k + 1) % 3],
        [k, (k + 2) % 3]
      ];

      for (const [i, j] of pairs) {
        if (colors[i] === RED && colors[j] === GREEN) {
          const a = points[i], b = points[j];
          const midpoint = computeMidpoint(a, b);
          edges.push(midpoint);
          if (isSpecial(a, b)) special_points.push(midpoint);
        }
      }
    }
    const centroidPoint = centroid(...points.map(p => p.getCoords()));
    edges.push(centroidPoint);
    special_points.push(centroidPoint);
  }

  console.log(special_points);
  return { coordinates, vertex_colors, edges, special_points };
}
```


```{ojs}
subTriangles = {
  const triangles = [], trianglesRG = [], trianglesRGB = [];
  const cpMap = coloredPointsMap.coloredPointsMap;

  // Upward
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coords = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ];
      const data = generateTriangleData(coords, cpMap);
      triangles.push(data);
      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {
        data.vertex_colors.has('blue') ? trianglesRGB.push(data) : trianglesRG.push(data);
      }
    }
  }

  // Downward
  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coords = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ];
      const data = generateTriangleData(coords, cpMap);
      triangles.push(data);
      if (data.vertex_colors.has('red') && data.vertex_colors.has('green')) {
        data.vertex_colors.has('blue') ? trianglesRGB.push(data) : trianglesRG.push(data);
      }
    }
  }

  return { triangles, trianglesRG, trianglesRGB };
}
```

```{ojs}
viewof plotALL = {
  const cpMap = coloredPointsMap.coloredPointsMap;

  const triangleFeatures = (triangles, fillColor) =>
    triangles.map(({ coordinates }) => {
      const pts = coordinates.map(c => cpMap.get(c.join(',')).getCoords());
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [[...pts, pts[0]].map(p => [p.x, p.y])]
        },
        properties: { fillColor }
      };
    });

  const makeEdgeLines = triangles =>
    triangles.flatMap(tri =>
      tri.edges.map((pt, i, arr) => {
        const next = arr[(i + 1) % arr.length];
        return Plot.line([pt, next], {
          x: "x",
          y: "y",
          stroke: "black",
          strokeWidth: 5
        });
      })
    );

  const makeSpecialPoints = triangles =>
    triangles.flatMap(tri =>
      tri.special_points
        .map(pt =>
          pt && pt.x !== undefined && pt.y !== undefined
            ? Plot.dot([pt], { x: "x", y: "y", fill: "white", stroke: "black", r: 5 })
            : null
        )
        .filter(Boolean)
    );

  const edgeLines = makeEdgeLines(subTriangles.trianglesRG);
  const edgeLinesRGB = makeEdgeLines(subTriangles.trianglesRGB);
  const special_pointsRG = makeSpecialPoints(subTriangles.trianglesRG);
  const special_pointsRGB = makeSpecialPoints(subTriangles.trianglesRGB);

  return Plot.plot({
    width: 800,
    height: 800,
    x: { label: "x", domain: [0, 1] },
    y: { label: "y", domain: [0, Math.sqrt(3) / 2] },
    marks: [
      Plot.geo(
        { type: "FeatureCollection", features: triangleFeatures(subTriangles.triangles, "white") },
        { fill: d => d.properties.fillColor, stroke: "black", strokeWidth: 1 }
      ),
      Plot.geo(
        { type: "FeatureCollection", features: triangleFeatures(subTriangles.trianglesRG, "rgba(255, 215, 0, 0.7)") },
        { fill: d => d.properties.fillColor, stroke: "black", strokeWidth: 1 }
      ),
      Plot.geo(
        { type: "FeatureCollection", features: triangleFeatures(subTriangles.trianglesRGB, "rgba(0, 0, 0, 0.25)") },
        { fill: d => d.properties.fillColor, stroke: "black", strokeWidth: 1 }
      ),
      ...edgeLines,
      ...edgeLinesRGB,
      Plot.dot(
        coloredPointsMap.coloredPoints.map(d => ({
          ...d,
          title: `(${d.barycentricTriple.join(", ")})`
        })),
        {
          x: "x",
          y: "y",
          fill: "color",
          r: 5,
          title: "title"
        }
      ),
      ...special_pointsRG,
      ...special_pointsRGB
    ]
  });
}
```




