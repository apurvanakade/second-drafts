---
title: Sperner's Lemma - Part 02
author: Apurva Nakade
date: 2025-05-16 09:44:57
categories: [combinatorics, triangles, coloring]
---

**DRAFT DOCUMENT**

```{ojs}
import {slider} from "@jashkenas/inputs"

// Add a slider for M = number of points to plot
viewof N = slider({
  min: 2,
  max: 20,
  step: 1,
  value: 5,
  width: 500,
  title: "Number of subdivisions"
});
```

```{ojs}
equilateral_triangle_vertices = [
  {x: 0, y: 0},
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2}
]
```

```{ojs}
barycentric_coords = {
  let result = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      result.push([i, j, N - i - j]);
    }
  }
  return result;
}
```


```{ojs}
// Utility function to calculate the centroid (median point) of a triangle
centroid = (p1, p2, p3) => {
  const cx = (p1.x + p2.x + p3.x) / 3;
  const cy = (p1.y + p2.y + p3.y) / 3;
  return { x: cx, y: cy };
};
```

```{ojs}
class ColoredPoint {
  constructor(triple, equilateralTriangleVertices, N) {
    this.barycentricTriple = triple;
    const [A, B, C] = equilateralTriangleVertices;

    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;
    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;

    this.color = this._assignColor(triple);
  }

  _assignColor(triple) {
    const [a, b, c] = triple;

    if (a === 0 && b === 0) return 'red';
    if (b === 0 && c === 0) return 'green';
    if (c === 0 && a === 0) return 'blue';

    // pick randomly between red and blue
    if (a === 0) return Math.random() < 0.5 ? 'red' : 'blue';
    if (b === 0) return Math.random() < 0.5 ? 'red' : 'green';
    if (c === 0) return Math.random() < 0.5 ? 'blue' : 'green';

    // pick randomly between red, green, and blue
    return Math.random() < 0.33 ? 'red' : (Math.random() < 0.5 ? 'green' : 'blue');
  }

  getCoords() {
    return { x: this.x, y: this.y };
  }

  getColor() {
    return this.color;
  }
}
```

```{ojs}
// A cell to generate all ColoredPoint instances
// and also create a map for efficient lookup.
// This cell effectively replaces your `generateColoredPoints` function and the map creation.
coloredPointsMap = {
  const coloredPoints = barycentric_coords.map(triple => {
    return new ColoredPoint(triple, equilateral_triangle_vertices, N);
  });

  // Create a Map for quick lookup of colored_points by their barycentric triple
  let coloredPointsMap = new Map();
  for (const p of coloredPoints) {
    coloredPointsMap.set(`${p.barycentricTriple[0]},${p.barycentricTriple[1]},${p.barycentricTriple[2]}`, p);
  }

  // Return both the array and the map
  return { coloredPoints, coloredPointsMap };
}
```


```{ojs}
subTriangles = {
  let triangles = [];
  // upward facing triangles
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coordinates = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ];
      const vertex_colors = new Set([
        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()
      ]);
      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors
    }
  }
  // downward facing triangles
  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coordinates = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ];
      const vertex_colors = new Set([
        coloredPointsMap.coloredPointsMap.get(`${coordinates[0][0]},${coordinates[0][1]},${coordinates[0][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[1][0]},${coordinates[1][1]},${coordinates[1][2]}`).getColor(),
        coloredPointsMap.coloredPointsMap.get(`${coordinates[2][0]},${coordinates[2][1]},${coordinates[2][2]}`).getColor()
      ]);
      triangles.push({ coordinates, vertex_colors }); // Added vertex_colors
    }
  }
  return triangles;
}
```


<!-- 
  TODO: Create a richer data structure to store the triangles and their edges.
  TODO: Connect centroids of triangles to sides of the same triangle instead of connecting centroids of triangles to centroids of other triangles.
  TODO: modify above methods while looping instead of creating a new cell.
 -->
 
```{ojs}
viewof plotEmpty = Plot.plot({
  width: 800,
  height: 800,
  x: {
    label: "x",
    domain: [0, 1]
  },
  y: {
    label: "y",
    domain: [0, Math.sqrt(3) / 2]
  },
  marks: [
    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {
      x: "x",
      y: "y",
      stroke: "black",
      strokeWidth: 1
    }),
    Plot.dot(coloredPointsMap.coloredPoints, {
      x: "x",
      y: "y",
      fill: d => d.color,
      r: 3
    }),
    Plot.geo(
      {
        type: "FeatureCollection",
        features: subTriangles.map(triangle => {
          let coords = triangle.coordinates.map(coord => coloredPointsMap.coloredPointsMap.get(`${coord[0]},${coord[1]},${coord[2]}`).getCoords());
          return {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [
                [coords[0], coords[1], coords[2], coords[0]].map(c => [c.x, c.y])
              ]
            },
            properties: { // empty fill color
              fillColor: "none",
              coords: coords, // Store the coordinates
              vertexColors: Array.from(triangle.vertex_colors) // Store vertex colors as array
            }
          };
        })
      },
      {
        fill: d => d.properties.fillColor, // Use the determined color.
        stroke: "black",
        strokeWidth: 1
      }
    ),
    // Add the dots to show all colored points with their assigned color
    Plot.dot(
      coloredPointsMap.coloredPoints,
      {
        x: "x",
        y: "y",
        fill: d => d.color,
        r: 5 // Slightly larger dots if desired
      }
    )
  ]
});
```


