---
title: Sperner's Lemma - Part 02
author: Apurva Nakade
date: 2025-05-16 09:44:57
categories: [combinatorics, triangles, coloring]
---

**DRAFT DOCUMENT**

```{ojs}
import { slider } from "@jashkenas/inputs"

viewof N = slider({
  min: 2,
  max: 20,
  step: 1,
  value: 5,
  width: 500,
  title: "Number of subdivisions"
})
```

```{ojs}
equilateral_triangle_vertices = [
  {x: 0, y: 0},
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2}
]
```

```{ojs}
barycentric_coords = {
  let result = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      result.push([i, j, N - i - j]);
    }
  }
  return result;
}
```


```{ojs}
centroid = (p1, p2, p3) => ({
  x: (p1.x + p2.x + p3.x) / 3,
  y: (p1.y + p2.y + p3.y) / 3
});
```

```{ojs}
randomChoice = (choices) => choices[Math.floor(Math.random() * choices.length)];

class ColoredPoint {
  constructor(triple, vertices, N) {
    this.barycentricTriple = triple;
    const [A, B, C] = vertices;

    this.x = (triple[0] * A.x + triple[1] * B.x + triple[2] * C.x) / N;
    this.y = (triple[0] * A.y + triple[1] * B.y + triple[2] * C.y) / N;

    this.color = this._assignColor(triple);
  }

  _assignColor([a, b, c]) {
    if (a === 0 && b === 0) return '#E74C3C';
    if (b === 0 && c === 0) return '#27AE60';
    if (c === 0 && a === 0) return '#2980B9';
    if (a === 0) return randomChoice(['#E74C3C', '#2980B9']);
    if (b === 0) return randomChoice(['#E74C3C', '#27AE60']);
    if (c === 0) return randomChoice(['#27AE60', '#2980B9']);
    return randomChoice(['#E74C3C', '#27AE60', '#2980B9']);
  }

  getCoords() {
    return { x: this.x, y: this.y };
  }

  getColor() {
    return this.color;
  }
}
```

```{ojs}
coloredPointsMap = {
  const coloredPoints = barycentric_coords.map(triple =>
    new ColoredPoint(triple, equilateral_triangle_vertices, N)
  );

  const map = new Map();
  for (const p of coloredPoints) {
    map.set(p.barycentricTriple.join(','), p);
  }

  return { coloredPoints, coloredPointsMap: map };
}
```


```{ojs}
generateTriangleData = (coordinates, cpMap) => {
  const [p0, p1, p2] = coordinates.map(coord => cpMap.get(coord.join(',')));
  const colors = [p0, p1, p2].map(p => p.getColor());
  const vertex_colors = new Set(colors);
  let edges = [];
  let special_points = [];

  if (vertex_colors.has('#E74C3C') && vertex_colors.has('#27AE60') && !vertex_colors.has('#2980B9')) {
    for (let k = 0; k < 3; k++) {
      if (colors[k] !== colors[(k + 1) % 3]) {
        const c1 = [p0, p1, p2][k].getCoords();
        const c2 = [p0, p1, p2][(k + 1) % 3].getCoords();
        const midpoint = {
          x: (c1.x + c2.x) / 2,
          y: (c1.y + c2.y) / 2
        };
        edges.push(midpoint);

        // check if the edge is an RG boundary edge
        // TODO: Fix this
        if (coordinates[k][0] === 0 && coordinates[(k + 1) % 3][0] === 0) {
          special_points.push(midpoint);
        }
      }
    }
  }

  if (vertex_colors.has('#E74C3C') && vertex_colors.has('#27AE60') && vertex_colors.has('#2980B9')) {
    for (let k = 0; k < 3; k++) {
        if ((colors[k] === '#E74C3C' && colors[(k + 1) % 3] === '#27AE60')) {
          const c1 = [p0, p1, p2][k].getCoords();
          const c2 = [p0, p1, p2][(k + 1) % 3].getCoords();
          edges.push({ x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 });
        }
        else if (colors[k] === '#E74C3C' && colors[(k + 2) % 3] === '#27AE60') {
          const c1 = [p0, p1, p2][k].getCoords();
          const c2 = [p0, p1, p2][(k + 2) % 3].getCoords();
          edges.push({ x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 });
        }
      }
      const centroidPoint = centroid(p0.getCoords(), p1.getCoords(), p2.getCoords());
      edges.push(centroidPoint);
      special_points.push(centroidPoint);
  }

  return { coordinates, vertex_colors, edges, special_points };
}
```


```{ojs}
subTriangles = {
  const triangles = [], trianglesRG = [], trianglesRGB = [];
  const cpMap = coloredPointsMap.coloredPointsMap;

  // Upward
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coords = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ];
      const data = generateTriangleData(coords, cpMap);
      triangles.push(data);
      if (data.vertex_colors.has('#E74C3C') && data.vertex_colors.has('#27AE60')) {
        data.vertex_colors.has('#2980B9') ? trianglesRGB.push(data) : trianglesRG.push(data);
      }
    }
  }

  // Downward
  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coords = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ];
      const data = generateTriangleData(coords, cpMap);
      triangles.push(data);
      if (data.vertex_colors.has('#E74C3C') && data.vertex_colors.has('#27AE60')) {
        data.vertex_colors.has('#2980B9') ? trianglesRGB.push(data) : trianglesRG.push(data);
      }
    }
  }

  return { triangles, trianglesRG, trianglesRGB };
}
```

```{ojs}
viewof plotALL = {
  const cpMap = coloredPointsMap.coloredPointsMap;

  const triangleFeatures = (triangles, fillColor) =>
    triangles.map(({ coordinates, vertex_colors }) => {
      const pts = coordinates.map(c => cpMap.get(c.join(',')).getCoords());
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [[...pts, pts[0]].map(p => [p.x, p.y])]
        },
        properties: { fillColor }
      };
    });

  const edgeLines = subTriangles.trianglesRG.flatMap(tri => {
    return tri.edges.map((pt, i, arr) => {
      const next = arr[(i + 1) % arr.length];
      return Plot.line([pt, next], {
        x: "x",
        y: "y",
        stroke: "black",
        strokeWidth: 5
      });
    });
  });

  const edgeLinesRGB = subTriangles.trianglesRGB.flatMap(tri => {
    return tri.edges.map((pt, i, arr) => {
      const next = arr[(i + 1) % arr.length];
      return Plot.line([pt, next], {
        x: "x",
        y: "y",
        stroke: "black",
        strokeWidth: 5
      });
    });
  });

  const special_points = subTriangles.trianglesRG.flatMap(tri => {
    return tri.special_points.map(pt => {
      if (pt && pt.x !== undefined && pt.y !== undefined) {
        return Plot.dot(pt, { x: "x", y: "y", fill: "black", r: 15 });
      }
      return null;
    }).filter(Boolean);
  });

  const special_pointsRGB = subTriangles.trianglesRGB.flatMap(tri => {
    return tri.special_points.map(pt => {
      if (pt && pt.x !== undefined && pt.y !== undefined) {
        return Plot.dot(pt, { x: "x", y: "y", fill: "black", r: 15 });
      }
      return null;
    }).filter(Boolean);
  });

  return Plot.plot({
    width: 800,
    height: 800,
    x: { label: "x", domain: [0, 1] },
    y: { label: "y", domain: [0, Math.sqrt(3) / 2] },
    marks: [
      Plot.geo(
        { type: "FeatureCollection", features: triangleFeatures(subTriangles.trianglesRG, "rgba(255, 215, 0, 0.7)") },
        { fill: d => d.properties.fillColor, stroke: "black", strokeWidth: 0 }
      ),
      Plot.geo(
        { type: "FeatureCollection", features: triangleFeatures(subTriangles.trianglesRGB, "rgba(179, 20, 207, 0.5)") },
        { fill: d => d.properties.fillColor, stroke: "black", strokeWidth: 0 }
      ),
      ...edgeLines,
      ...edgeLinesRGB,
      Plot.dot(
        coloredPointsMap.coloredPoints.map(d => ({
          ...d,
          title: `(${d.barycentricTriple.join(", ")})`
        })),
        {
          x: "x",
          y: "y",
          fill: "color",
          r: 5 * (5 / N),
          title: "title"
        }
      ),
      // plot the special points
      ...special_points,
      ...special_pointsRGB
    ]
  });
}
```

// TODO: Special points are not being plotted correctly



