---
title: Sperner's Lemma - Geometric Proof
author: Apurva Nakade
date: 2025-05-22 10:23:17
categories: [triangles, coloring, questions, visualization, interactive, observablejs]
---

```{ojs}
import {slider} from "@jashkenas/inputs"

// Add a  for M = number of points to plot
viewof N = slider({
  min: 2,
  max: 20,
  step: 1,
  value: 5,
  width: 500,
  title: "Number of subdivisions"
});
```

```{ojs}
// make a slider from 0 to 1
viewof t = slider({
  min: 0,
  max: 1,
  step: 0.01,
  value: 1,
  width: 500,
  title: "time"
});
```

```{ojs}
equilateral_triangle_vertices = [
  {x: 1, y: 0},
  {x: 0.5, y: Math.sqrt(3) / 2},
  {x: 0, y: 0},
]
```

```{ojs}
barycentric_coords = {
  let result = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      result.push([i, j, N - i - j]);
    }
  }
  return result;
}
```

```{ojs}
colorMap = {
  const map = new Map();

  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      const k = N - i - j;
      const triple = [i, j, k];
      const [a, b, c] = triple;

      let color;
      if (a === 0 && b === 0) color = 'red';
      else if (b === 0 && c === 0) color = 'green';
      else if (c === 0 && a === 0) color = 'blue';
      else if (a === 0) color = Math.random() < 0.5 ? 'red' : 'blue';
      else if (b === 0) color = Math.random() < 0.5 ? 'red' : 'green';
      else if (c === 0) color = Math.random() < 0.5 ? 'blue' : 'green';
      else {
        const r = Math.random();
        color = r < 0.33 ? 'red' : (r < 0.66 ? 'green' : 'blue');
      }

      map.set(`${a},${b},${c}`, color);
    }
  }

  return map;
}
```

```{ojs}
morphedColoredPointsMap = {
  const vertexMap = {
    red: equilateral_triangle_vertices[2],
    green: equilateral_triangle_vertices[0],
    blue: equilateral_triangle_vertices[1]
  };

  const barycentric_coords = [];
  for (let i = 0; i <= N; i++) {
    for (let j = 0; j <= N - i; j++) {
      barycentric_coords.push([i, j, N - i - j]);
    }
  }

  const morphedPoints = [];
  const morphedMap = new Map();
  const [A, B, C] = equilateral_triangle_vertices;

  for (const triple of barycentric_coords) {
    const [a, b, c] = triple;
    const x0 = (a * A.x + b * B.x + c * C.x) / N;
    const y0 = (a * A.y + b * B.y + c * C.y) / N;

    const color = colorMap.get(`${a},${b},${c}`);
    const vertex = vertexMap[color];

    const x = t * x0 + (1 - t) * vertex.x;
    const y = t * y0 + (1 - t) * vertex.y;

    const point = { x, y, color, barycentricTriple: triple };

    morphedPoints.push(point);
    morphedMap.set(`${a},${b},${c}`, point);
  }

  return { morphedPoints, morphedMap };
}
```

```{ojs}
subTriangles = {
  let triangles = [];

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N - i; j++) {
      const coords = [
        [i, j, N - i - j],
        [i + 1, j, N - i - j - 1],
        [i, j + 1, N - i - j - 1]
      ];
      const vertex_colors = coords.map(c => morphedColoredPointsMap.morphedMap.get(`${c[0]},${c[1]},${c[2]}`).color);
      triangles.push({ coordinates: coords, vertex_colors });
    }
  }

  for (let i = 0; i < N - 1; i++) {
    for (let j = 0; j < N - i - 1; j++) {
      const coords = [
        [i + 1, j, N - i - j - 1],
        [i + 1, j + 1, N - i - j - 2],
        [i, j + 1, N - i - j - 1]
      ];
      const vertex_colors = coords.map(c => morphedColoredPointsMap.morphedMap.get(`${c[0]},${c[1]},${c[2]}`).color);
      triangles.push({ coordinates: coords, vertex_colors });
    }
  }

  return triangles;
}
```

```{ojs}
getFillColorRGB = (vertexColorsOrdered) => {
  // Map full color names to single-letter codes
  const colorMap = {
    red: 'R',
    green: 'G',
    blue: 'B'
  };

  // Convert full names to letters
  const orientation = vertexColorsOrdered.map(c => colorMap[c.toLowerCase()] || '').join('').toUpperCase();

  const group1 = new Set(['RGB', 'GBR', 'BRG']);
  const group2 = new Set(['RBG', 'BGR', 'GRB']);

  if (group1.has(orientation)) {
    return 'rgba(255, 255, 0, 0.4)';  // semi-transparent yellow
  } 
  else if (group2.has(orientation)) {
    return 'rgba(255, 0, 255, 0.4)';  // semi-transparent teal
  }

  return 'none';
};
```

```{ojs}
viewof plotRGB = Plot.plot({
  width: 800,
  height: 800,
  x: {
    label: "x",
    domain: [0, 1]
  },
  y: {
    label: "y",
    domain: [0, Math.sqrt(3) / 2]
  },
  marks: [
    Plot.line([...equilateral_triangle_vertices, equilateral_triangle_vertices[0]], {
      x: "x",
      y: "y",
      stroke: "black",
      strokeWidth: 1
    }),

    Plot.geo(
      {
        type: "FeatureCollection",
        features: subTriangles.map(triangle => {
          let coords = triangle.coordinates.map(coord => {
            const point = morphedColoredPointsMap.morphedMap.get(`${coord[0]},${coord[1]},${coord[2]}`);
            return point ? { x: point.x, y: point.y } : { x: 0, y: 0 }; // fallback for safety
          });

          return {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [[
                [coords[0].x, coords[0].y],
                [coords[1].x, coords[1].y],
                [coords[2].x, coords[2].y],
                [coords[0].x, coords[0].y]
              ]]
            },
            properties: {
              fillColor: getFillColorRGB(triangle.vertex_colors),  // now an array
              coords: coords,
              vertexColors: triangle.vertex_colors  // already an array, no conversion needed
            },
          };
        })
      },
      {
        fill: d => d.properties.fillColor,
        stroke: "black",
        strokeWidth: 1
      }
    ),

    // Plot morphed colored points
    Plot.dot(
      morphedColoredPointsMap.morphedPoints,
      {
        x: "x",
        y: "y",
        fill: d => d.color,
        r: 5 * (5 / N)
      }
    )
  ]
});
```